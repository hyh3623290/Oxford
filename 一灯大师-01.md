# JavaScript

1⃣️

```js
alert(a)
a()
var a = 3
function a() {
  alert(10)
}
alert(a)
a = 6
a()
```

- 变量提升
- 函数提升
- 函数提升优先于变量提升，也就是函数在最上头⚠️去百度一下 
- 如果变量名和函数名重名，变量又没有被赋值，则函数生效

```js
function
10
3
报错: a is not function
```





2⃣️

```js
var a = function yideng(num) {
  yideng = num
  console.log(typeof yideng)
  return 1
}
a(1)
console.log(typeof yideng())
```

- yideng是只读的，且只在内部使用。在node中这样使用其实一般就是为了调错的

```js
function
yideng is not defined  
```



3⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: function() {
    console.log(this.a)
  }
}
test.init() // 40
var fn = test.init()
fn() // 20
```

- this谁调用指谁，init是谁执行的？-> test	fn是谁执行的 -> window



4⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: function() {
    function go() {
      console.log(this.a)
    }
    go()
  }
}
test.init() // 20
```

- `test.init()` 是 `go()` `go`没人调用, 所以是`window`





5⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: function() {
    function go() {
      console.log(this.a)
    }
    return go
  }
}
var s = test.init()
s() // 20
```

- 与上同理





6⃣️

```js
function test(a) {
  this.a = a
}
test.prototype.a = 20
test.prototype.init = function() {
  console.log(this.a)
}
var s = new test(30)
s.init() // 30
```

- 构造函数的值优先于原型链





7⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: function() {
    console.log(this.a)
  }
} // 缺了一个分号，报错
(function(){
  var fn = test.init()
  n()
})()
```





8⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: () => {
    console.log(this.a)
  }
}
test.init() // 20
var fn = test.init()
fn() // 20
```

- 箭头函数绑定父级作用域，跟写bind的意思一模一样





9⃣️

```js
this.test = 11
var s = {
  a: function() {
    console.log(1)
    console.log(this)
    console.log(this.test)
  },
  b() {
    console.log(this.test)
  }
}

var f = s.a.bind(this)
new f() // 1 a{} undefined 没有new的话第二个输出window
var f2 = s.b.bind(this)
new f2() // 报错
```

- es6简写方式不支持new，包括箭头函数
- new了以后this指向那个实例，所以输出`a{}`

```js
function f() {console.log(this)}

new f() // f{}
```







🔟



```js
this.a = 20
var test = {
  a: 40,
  init: () => { // function()
    console.log(this.a)
    function go() {
      this.a = 60
      console.log(this.a)
    }
    go.prototype.a = 50
    return go
  }
}
console.log(1+'*********************')
test.init()
console.log(2+'*********************')
var p = test.init()
console.log(3+'*********************')
p()
console.log(4+'*********************')
new (test.init())()
```

20 20 60 60 60

```js
 1*********************
// 20
 2*********************
// 20
 3*********************
// 60
 4*********************
// 60
// 60
```

⚠️ debugger看看明天



1⃣️1⃣️

```js
new 运算符的优先级到底是什么样的
```



1⃣️2⃣️

```js
function test(m) {
  m = {
    v: 5
  }
}
var m = {
  k: 30
}
test(m)
alert(m.v) // undefined

function test(m) {
  m.v = 20
}
var m = {
  k: 30
}
test(m)
alert(m.v) // 20

//上面为了迷惑
function test(a) {
  a.v = 20
}
var m = {
  k: 30
}
test(m)
alert(m.v) // 20
```

- 函数的参数是按值传递，和外面什么关系都没有
- 但后面例子，a和m的指向是同一个地址





1⃣️3⃣️

```js
function yideng() {
  console.log(1)
}
(function(){
  // var yideng -> 现代浏览器
  if(false) {
    function yideng() {
      console.log(2)
    }
  }
  yideng()
})()
```

- 浏览题问题，三种结果

  1. 老式浏览器 - 函数提升输出2
  2. 现代浏览器会将一灯提上来然后报错
  3. 中间某些火狐浏览器输出1

  此外类似`[,,].length`也有2有3





1⃣️4⃣️

请用一句话算出0-100之间学生的学生等级，如90-100为1等生，80-90为2等生以此类推。不允许使用`if switch`

思维：100 10 98 1	有什么关系

```js
10 - 98/10 = 1
```



1⃣️5⃣️

请用一句话遍历变量`a = "abc"`

```js
var a = "abc"

Array.from(a)
[...new Set(a)]
Array.prototype.slice.call(a) // 很多类库都这么干，使用call更灵活
```



🔟6⃣️

请写出JS的继承 1.45 不想看了

```js
function Car(color) {
  this.color = color
}
Car.prototype.show = function() { console.log(this.color) }

function Benz(color) {
  Car.call(this, color)
}
Benz.prototype = Object.create(Car.prototype)
Benz.prototype.test = function() {}

const benz = new Benz("red")
console.log(benz)
```



🔟7⃣️

```js
var length = 10
function fn(){
  console.log(this.length)
}
var yideng = {
  length: 5,
  method: function(fn) {
    fn()
    arguments[0]()
  }
};
yideng.method(fn, 1)
```

- 没有人调fn，this指向window
- window.length = 页面中iframe的个数



🔟8⃣️

```js
function yideng() {}
yideng.prototype.a = 11
yideng.a // undefined
```

- 你得new它的时候才会去原型链上找



🔟9⃣️

原型链图 + 原型链 第二节













⚠️ 额外：手写bind，深拷贝，防抖节流



⚠️ 看到题目先看提升，其次看点

⚠️ 函数作用域可以做私有变量

































