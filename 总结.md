[toc]

# 2.16

## 什么是自由变量

​	既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量

## 动态作用域和词法作用域

- 在代码运行时完成划分，作用域链沿着它的**调用栈**往外延伸
- 在代码书写的时候完成划分，作用域链沿着它**定义的位置**往外延伸

## 闭包的作用

模拟私有变量

```js
const User = (function () {
  // 定义私有变量_password
  let _password

  class User {
    constructor(username, password) {
      // 初始化私有变量_password
      _password = password
      this.username = username
    }

    login() {
      // 这里我们增加一行 console，为了验证 login 里仍可以顺利拿到密码
      console.log(this.username, _password)
    }
  }
  return User
})()

let user = new User('xiuyan', 'xiuyan123')
```

## 内存泄漏的一些原因

1. “手滑” 导致的全局变量

```js
function test() {
  me = 'xiuyan'
}
// 导致这个 me 被默默地挂载到全局对象上, 永远无法被清除
```

2. 忘记清除的 setInterval 和 setTimeout
3. 清除不当的 DOM

```js
const myDiv = document.getElementById('myDiv')

function handleMyDiv() {
  一些与myDiv相关的逻辑
}
handleMyDiv()

document.body.removeChild(document.getElementById('myDiv'));
// myDiv 这个变量对这个 DOM 的引用仍然存在
```



## 实现call方法

```js
Function.prototype.myCall = function(context, ...args) {
  context.func = this
  context.func(...args)
  delete context.func
}
```



## 类数组转换有几种方法

```js
const arr = Array.prototype.slice.call(arrayLike);

const arr = Array.from(arrayLike);

function demo() {
  console.log('转换后的 arguments 对象：', [...arguments])
}
```

## 防抖节流

```js
function throttle(fn, interval) {
  let last = 0
  return function() {
    let context = this
    let now = new Date()
    let args = argument
    if(now - last > interval) {
      last = now
      fn.apply(context, args)
    }
  }
}

function debounce(fn, delay) {
  let timer = null
  return function() {
    let args = arguments
    let context = this
    if(timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, args)
    },delay)
  }
}
```

# 2.17

## 说一下generator

​	就是普通的函数前面加一个星号，当我们调用它不会立即执行，而是得到一个生成器对象，只有调用它的next这时候才开始执行, 并拿到返回值。我们在函数里随时使用这个yield关键字向外返回一个值，但它不像return立即结束，而是暂停函数的执行，当我们调用next时如果传参数会代替yield的返回值



# 2.18 - 2.21

## 手写createElement

```js
function createElement(type, props, ...children) {
  const childElements = [].concat(...children).reduce((result, child) => {
    if(child !== false && child !== true && child !== null) {
      if(child instanceof Object) {
        result.push(child)
      } else {
        result.push(createElement('text', { textContent: child }))
      }
    }
    return result
  }, [])
  return {
    type,
    props: Object.assign({ children: childElements }, props),
    children: childElements
  }
}

返回虚拟dom
处理children, 移除null和布尔值, 处理文本节点
将children挂到props上
```

​	这样jsx就会自动被执行createElement方法，我们就会拿到createElement的返回结果，就是一个virtual dom对象



## 手写ReactDOM.render

```js

```



```js

```



# ^_^

```js

```

