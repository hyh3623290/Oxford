[toc]

# 2.15

## 什么是自由变量

​	既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量

## 动态作用域和词法作用域

- 在代码运行时完成划分，作用域链沿着它的**调用栈**往外延伸
- 在代码书写的时候完成划分，作用域链沿着它**定义的位置**往外延伸

## 闭包的作用

模拟私有变量

```js
const User = (function () {
  // 定义私有变量_password
  let _password

  class User {
    constructor(username, password) {
      // 初始化私有变量_password
      _password = password
      this.username = username
    }

    login() {
      // 这里我们增加一行 console，为了验证 login 里仍可以顺利拿到密码
      console.log(this.username, _password)
    }
  }
  return User
})()

let user = new User('xiuyan', 'xiuyan123')
```

## 内存泄漏的一些原因

1. “手滑” 导致的全局变量

```js
function test() {
  me = 'xiuyan'
}
// 导致这个 me 被默默地挂载到全局对象上, 永远无法被清除
```

2. 忘记清除的 setInterval 和 setTimeout
3. 清除不当的 DOM

```js
const myDiv = document.getElementById('myDiv')

function handleMyDiv() {
  一些与myDiv相关的逻辑
}
handleMyDiv()

document.body.removeChild(document.getElementById('myDiv'));
// myDiv 这个变量对这个 DOM 的引用仍然存在
```



## 实现call方法

```js
Function.prototype.myCall = function(context, ...args) {
  // step1: 把函数挂到目标对象上（这里的 this 就是我们要改造的的那个函数）
  context.func = this
  // step2: 执行函数
  context.func(...args)
  // step3: 删除 step1 中挂到目标对象上的函数，把目标对象”完璧归赵”
  delete context.func
}
```



## 类数组转换有几种方法

```js
const arr = Array.prototype.slice.call(arrayLike);

const arr = Array.from(arrayLike);

function demo() {
  console.log('转换后的 arguments 对象：', [...arguments])
}
```

## 防抖节流

```js
function throttle(fn, interval) {
  let last = 0
  return function() {
    let context = this
    let now = new Date()
    let args = argument
    if(now - last > interval) {
      last = now
      fn.apply(context, args)
    }
  }
}

function debounce(fn, delay) {
  let timer = null
  return function() {
    let args = arguments
    let context = this
    if(timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, args)
    },delay)
  }
}
```









# ^_^

```js
function throttle(fn, interval) {
  let last = 0
  return function() {
    let context = this
    let now = new Date()
    let args = argument
    if(now - last > interval) {
      last = now
      fn.call(context, ...args)
    }
  }
}

function debounce(fn, delay) {
  let timer = null
  return function() {
    if(timer) {
      clearTimeout(timer)
    }
    let args = arguments
    timer = setTimeout(() => {
      fn.apply(this, args)
    },delay)
  }
}
```

