[toc]

# 2.16

## 什么是自由变量

​	既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量

## 动态作用域和词法作用域

- 在代码运行时完成划分，作用域链沿着它的**调用栈**往外延伸
- 在代码书写的时候完成划分，作用域链沿着它**定义的位置**往外延伸

## 闭包的作用

模拟私有变量

```js
const User = (function () {
  // 定义私有变量_password
  let _password

  class User {
    constructor(username, password) {
      // 初始化私有变量_password
      _password = password
      this.username = username
    }

    login() {
      // 这里我们增加一行 console，为了验证 login 里仍可以顺利拿到密码
      console.log(this.username, _password)
    }
  }
  return User
})()

let user = new User('xiuyan', 'xiuyan123')
```

## 内存泄漏的一些原因

1. “手滑” 导致的全局变量

```js
function test() {
  me = 'xiuyan'
}
// 导致这个 me 被默默地挂载到全局对象上, 永远无法被清除
```

2. 忘记清除的 setInterval 和 setTimeout
3. 清除不当的 DOM

```js
const myDiv = document.getElementById('myDiv')

function handleMyDiv() {
  一些与myDiv相关的逻辑
}
handleMyDiv()

document.body.removeChild(document.getElementById('myDiv'));
// myDiv 这个变量对这个 DOM 的引用仍然存在
```



## 实现call方法

```js
Function.prototype.myCall = function(context, ...args) {
  context.func = this
  context.func(...args)
  delete context.func
}
```



## 类数组转换有几种方法

### 使用...的前提

​	前提是这个类数组对象上部署了遍历器接口，比如函数内部的 arguments 变量

```js
const arr = Array.prototype.slice.call(arrayLike);

const arr = Array.from(arrayLike);

function demo() {
  console.log('转换后的 arguments 对象：', [...arguments])
}
```

## 函数使用...

```js
function a(x, ...args) {
  console.log(args) 
  console.log(...args)
}
a(1,2,3,4) 
// [2, 3, 4] 
// 2 3 4
```





## 防抖节流

```js
function throttle(fn, interval) {
  let last = 0
  return function() {
    let context = this
    let now = new Date()
    let args = argument
    if(now - last > interval) {
      last = now
      fn.apply(context, args)
    }
  }
}

function debounce(fn, delay) {
  let timer = null
  return function() {
    let args = arguments
    let context = this
    if(timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, args)
    },delay)
  }
}
```



# 2.17

## 说一下generator

​	就是普通的函数前面加一个星号，当我们调用它不会立即执行，而是得到一个生成器对象，只有调用它的next这时候才开始执行, 并拿到返回值。我们在函数里随时使用这个yield关键字向外返回一个值，但它不像return立即结束，而是暂停函数的执行，当我们调用next时如果传参数会代替yield的返回值



# 2.18 - 2.21

## 手写createElement

```js
function createElement(type, props, ...children) {
  const childElements = [].concat(...children).reduce((result, child) => {
    if(child !== false && child !== true && child !== null) {
      if(child instanceof Object) {
        result.push(child)
      } else {
        result.push(createElement('text', { textContent: child }))
      }
    }
    return result
  }, [])
  return {
    type,
    props: Object.assign({ children: childElements }, props),
    children: childElements
  }
}

返回虚拟dom
处理children, 移除null和布尔值, 处理文本节点
将children挂到props上
```

​	这样jsx就会自动被执行createElement方法，我们就会拿到createElement的返回结果，就是一个virtual dom对象



## 手写ReactDOM.render

```js
function render(virtualDOM, container, oldDOM = container.firstChild) {
  diff(virtualDOM, container, oldDOM)
}

function diff(virtualDOM, container, oldDOM) {
  const oldVirtualDOM = oldDOM && oldDOM._virtualDOM
  const oldComponent = oldVirtualDOM && oldVirtualDOM.component
  if(!oldDOM) {
    mountElement(virtualDOM, container)
  } else if(virtualDOM.type !== oldVirtualDOM.type && typeof virtualDOM.type !== 'function') {
    const newElement = createDOMElement(virtualDOM)
    oldDOM.parentNode.replaceChild(newElement, oldDOM)
  } else if(typeof virtualDOM.type === "function") {
    // 组件
    diffComponent(virtualDOM, oldComponent, oldDOM, container)
  } else if(oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
    if(virtualDOM.type === "text") {
      updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)
    } else {
      // 更新元素节点属性
      updateNodeElement(oldDOM, virtualDOM, oldVirtualDOM)
    }

    // 处理key
    // 1. 将拥有key属性的子元素放到单独的一个对象中
    let keyedElements = {}
    for(let i = 0, len = oldDOM.childNodes.lendgh; i<len; i++) {
      let domElement = oldDOM.childNodes[i]
      if(domElement.nodeType === 1) {
        // 元素节点
        let key = domElement.getAttribute('key')
        if(key) {
          keyedElements[key] = domElement
        }
      }
    }

    let hasNoKey = Object.keys(keyedElements).length === 0

    if(hasNoKey) {
      virtualDOM.children.forEach((child, i) => {
        diff(child, oldDOM, oldDOM.childNodes[i])
      })
    } else {
      // 循环virtual DOM的子元素 获取子元素的key属性
      virtualDOM.children.forEach((child, i) => {
        let key = child.props.key
        if(key) {
          let domElement = keyedElements[key]
          if(domElement) {
            // 看看当前位置的元素是不是我们期望的元素
            if(oldDOM.childNodes[i] && oldDOM.childNodes[i] !== domElement) {
              oldDOM.insertBefore(domElement, oldDOM.childNodes[i])
            }
          }
        } else {
          // 新增元素
          mountElement(child, oldDOM, oldDOM.childNodes[i])
        }
      })
    }
    // 删除节点
    let oldChildNodes = oldDOM.childNodes
    if(oldChildNodes.length > virtualDOM.children.lendgh) {
      if(hasNoKey) {
        for(let i=oldChildNodes.length-1; i>virtualDOM.children.length-1; i--) {
          unMountNode(oldChildNodes[i])
        }
      } else {
        // 通过key属性删除节点
        for(let i=0; i<oldChildNodes.length; i++) {
          let oldChild = oldChildNodes[i]
          let oldChildKey = oldChild._virtualDOM.props.key
          let found = false
          for(let n=0; n<virtualDOM.children.length; n++) {
            if(oldChildKey === virtualDOM.children[n].props.key) {
              found = true
              break
            }
          }
          if(!found) {
            unMountNode(oldChild)
          }
        }
      }
    }
  }
}
/**
 * 如果oldDOM不存在，直接将虚拟dom转为真实dom挂载
 * 如果存在就要开始比对了
 *   首先如果是节点类型不一样且新的节点不是组件就直接创建dom并替换旧节点
 *   如果是组件就用组件的diff方法
 *   如果节点类型相同
 *      判断是文本还是普通元素再继续比对
 *      接下来根据key处理子元素
 *        先把拥有key的子元素单独放到一个对象中备用，如果这个对象为空，就直接递归的进行比对
 *        循环新vdom拿到vdom的key，看下那个对象里有没有这个key对应的元素
 *          有的话还要继续判断位置是否正确，不正确的话直接把新的插入到当前这个位置的前面
 *        如果新的vdom里某个元素没有key，直接挂载它
 *        后面还要删除多余节点
 *          如果旧的节点数量大于新的节点数量，则需要删除
 *             如果没有用key的话直接从后面删除即可，直到新旧dom的长度相等
 *             使用key来删除的话要两层循环，第一层循环旧dom，第二层循环新的dom
 *                如果能在新的dom里找不到旧的key，则删除这个节点
 */

function unMountNode(node) {
  const virtualDOM = node._virtualDOM
  if(virtualDOM.type === 'text') {
    node.remove()
    return
  }

  let component = virtualDOM.component
  // 如果component存在，就说明节点是由组件生成的
  if(component) {
    component.componentWillUnMount()
  }

  if(virtualDOM.props && virtualDOM.props.ref) {
    virtualDOM.props.ref(null)
  }

  Object.keys(virtualDOM.props).forEach(propName => {
    if(propName.slice(0, 2) === "on") {
      const eventName = propName.toLowerCase().slice(2)
      const eventhandler = virtualDOM.props[propName]
      node.removeEventListener(eventName, eventhandler)
    }
  })

  if(node.childNodes.length > 0) {
    for(let i=0; i<node.childNodes.length; i++) {
      unMountNode(node.childNodes[i])
      i--
    }
  }

  node.remove()
}
/**
 * 如果是文本节点直接删除
 * 如果是组件生成的，还要调用它的生命周期函数
 * 如果有ref，调用ref函数并传入null
 * 如果有事件要移除事件处理函数
 * 如果有子元素递归的删除子元素
 */

function diffComponent(virtualDOM, oldComponent, oldDOM, container) {
  if(isSameComponent(virtualDOM, oldComponent)) {
    // 同一个组件，做组件更新操作
    updateComponent(virtualDOM, oldComponent, oldDOM, container)
  } else {
    // 不是同一个组件
    mountElement(virtualDOM, container, oldDOM)
  }
}
/**
 * 如果是同一个组件则调用组件更新操作
 * 否则直接挂载新的组件
 */

function isSameComponent(virtualDOM, oldComponent) {
  return oldComponent && virtualDOM.type === oldComponent.constructor
}
/**
 * 判断旧的组件实例的constructor是否与vdom的type一致
 */

function updateComponent(virtualDOM, oldComponent, oldDOM, container) {
  // 生命周期53.25
  oldComponent.componentWillReceiveProps(virtualDOM.props)
  if(oldComponent.shouldComponentDidUpdate(virtualDOM.props)) {
    oldComponent.componentWillUpdate(virtualDOM.props)
    // 组件更新
    oldComponent.updateProps(virtualDOM.props)
    let nextVirtualDOM = oldComponent.render()
    nextVirtualDOM.component = oldComponent
    diff(nextVirtualDOM, container, oldDOM)
    oldComponent.componentDidUpdate()
  }
}
/**
 * 调用旧的组件的更新props方法
 * 执行旧组件的render方法返回拿到组件对应的jsx元素，获取新的vdom
 * 给vdom加一个属性存放组件实例
 * 调用diff函数
 */

function updateTextNode(virtualDOM, oldVirtualDOM, oldDOM) {
  if(virtualDOM.props.textContent !== oldVirtualDOM.props.textContent) {
    oldDOM.textContent = virtualDOM.props.textContent
    oldDOM._virtualDOM = virtualDOM
  }
}
/**
 * 如果textContent不一致，直接更新oldDOM的textContent
 * 记得把新的虚拟dom继续放到dom元素上以备下次diff
 */

function isFunction(virtualDOM) {
  return virtualDOM && typeof virtualDOM.type === "function"
}
/**
 * 判断是否是一个组件
 * 如果virtualDOM的type是函数类型说明是
 */

function mountElement(virtualDOM, container, oldDOM) {
  if(isFunction(virtualDOM)) {
    // Component
    mountComponent(virtualDOM, container, oldDOM)
  } else {
    // 普通jsx
    mountNativeElement(virtualDOM, container, oldDOM)
  }
}
/**
 * 如果是组件调用组件方法
 * 如果是普通元素调用普通元素方法
 */

function mountNativeElement(virtualDOM, container, oldDOM) {
  let newElement = createDOMElement(virtualDOM)
  if(oldDOM) {
    container.insertBefore(newElement, oldDOM)
  } else {
    container.appendChild(newElement)
  }
  if(oldDOM) {
    unMountNode(oldDOM)
  }
  
  let component = virtualDOM.component
  if(component) {
    component.setDOM(newElement)
  }
}
/**
 * 挂载普通jsx元素
 *  调用createDOMElement返回真实dom并插入container
 *  如果有旧的dom插入旧的dom前面并且卸载旧的dom
 *  如果新的dom有component实例，说明是组件过来的
 *    调用实例的setDOM方法把dom挂到实例上
 */

function createDOMElement(virtualDOM) {
  let newElement = null
  if(virtualDOM.type === "text") {
    newElement = document.createTextNode(virtualDOM.props.textContent)
  } else {
    newElement = document.createElement(virtualDOM.type)
    updateNodeElement(newElement, virtualDOM)
  }
  // 存放旧的vdom
  newElement._virtualDOM = virtualDOM
  virtualDOM.children.forEach(child => {
    mountElement(child, newElement)
  })
  if(virtualDOM.props && virtualDOM.props.ref) {
    virtualDOM.props.ref(newElement)
  }

  return newElement
}
/**
 * 通过判断是否是text分别调用不同的dom的创建方法
 *  如果不是text记得更新属性
 *  还要记得把virtualDOM挂到元素上，因为下次diff要知道旧的dom
 *  递归挂载子元素
 *  如果有ref属性的话执行它的方法把这个新的dom元素传进去
 */

function updateNodeElement(newElement, virtualDOM, oldVirtualDOM = {}) {
  const newProps = virtualDOM.props || {}
  const oldProps = oldVirtualDOM.props || {}
  // 更新属性
  Object.keys(newProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if(newPropsValue !== oldPropsValue) {
      if(propName.slice(0,2) === 'on') {
        const eventName = propName.toLowerCase().slice(2)
        newElement.addEventListener(eventName, newPropsValue)
        if(oldPropsValue) {
          newElement.removeEventListener(eventName, oldPropsValue)
        }
      } else if(propName === "value" || propName === "checked") {
        // value || checked 不能用setAttribute设置
        newElement[propName] = newPropsValue
      } else if(propName !== 'children') {
        if(propName === "className") {
          newElement.setAttributes('class', newPropsValue)
        } else {
          newElement.setAttributes(propName, newPropsValue)
        }
      }
    }
  })
  // 判断属性被删除的情况，old里面有，new里面没有
  Object.keys(oldProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if(!newPropsValue) {
      // 属性被删除了
      if(propName.slice(0, 2) === 'on') {
        const eventName = propName.toLowerCase().slice(2)
        newElement.removeEventListener(eventName, oldPropsValue)
      } else if(propName !== "children") {
        newElement.removeAttribute(propName)
      }
    }
  })
}
/**
 * 更新属性就是从props里拿，遍历它,如果新属性与旧属性不相等
 *  就给加上新的属性，同时需要判断如下几种情况
 *  事件，value||checked，children，className，普通属性
 * 删除旧的属性，遍历旧的props，如果和新的不一致就删除它
 */

function mountComponent(virtualDOM, container, oldDOM) {
  let component = null
  const nextVirtualDOM = null
  if(isFunctionComponent(virtualDOM)) {
    // 函数组件
    nextVirtualDOM = buildFunctionComponent(virtualDOM)
  } else {
    // 类组件，原型上面有render方法
    nextVirtualDOM = buildClassComponent(virtualDOM)
    component = nextVirtualDOM.component
  }
  if(isFunction(nextVirtualDOM)) {
    mountComponent(nextVirtualDOM, container, oldDOM)
  } else {
    mountNativeElement(nextVirtualDOM, container, oldDOM)
  }
  // 处理组件ref
  if(component) {
    component.componentDidMount()
    if(component.props && component.props.ref) {
      component.props.ref(component)
    }
  }
}
/**
 * 需要判断是函数组件还是类组件
 *  执行对应的方法拿到返回的jsx元素，类元素的话需要拿到它对应的实例
 *  再根据jsx执行对应的挂载方法
 *  实例的props里如果有ref的话执行它并把实例传进去
 */

function isFunctionComponent(virtualDOM) {
  const type = virtualDOM.type
  return type && isFunction(virtualDOM) && !(type.prototype && type.prototype.render)
}
/**
 * 看原型上是否有render方法
 */

function buildFunctionComponent(virtualDOM) {
  return virtualDOM.type(virtualDOM.props || {})// props就在vdom的props里存放
}
/**
 * 函数组件直接执行构造函数并传入props拿到vdom
 */

function buildClassComponent(virtualDOM) {
  const component = new virtualDOM.type(virtualDOM.props || {})
  const nextVirtualDOM = component.render()
  nextVirtualDOM.component = component
  return nextVirtualDOM
}
/**
 * 类组件实例化其构造函数（传入props），并执行它的render方法拿到vdom
 */

// extends React.Component
class Component {
  constructor(props) {
    this.props = props
  }
  setState(state) {
    this.state = Object.assign({}, this.state, state)
    // 获取最新的要渲染的vdom对象
    let virtualDOM = this.render()
    let oldDOM = this.getDOM()
    let container = oldDOM.parentNode
    diff(virtualDOM, container, oldDOM)
  }
  setDOM(dom) {
    this._dom = dom
  }
  getDOM() {
    return this._dom
  }
  updateProps(props) {
    this.props = props
  }
  // 生命周期函数
  // ...
  componentDidMount() {}
}
/**
 * 需要定义实例的props
 * setState方法把新的state加到旧的里面
 *    然后调用diff进行更新操作
 * 因为比对的时候需要拿到旧的dom，所以这里要定义setDOM方法，
 *   要把dom放到实例对象上，这样就可以通过实例获取dom
 *   每次构建类组件时都要调用setDom方法
 * 因为要更新props所以要定义updateProps方法
 * 还要定义生命周期方法
 */
```



# 2.21

## 事件的target和currentTarget有什么区别

​	currentTarget是会变的，指的是当前触发事件的元素，target指的是触发事件的那个元素，就是具体点击哪个元素，target就是谁，跟这个事件是否绑定在它上面没有关系



## 如何手动创建事件对象以及如何触发

```js
var clickAEvent = new Event('clickA');

divB.addEventListener('clickA', function (e) {
  console.log('我是小B，我感觉到了小A')
  console.log(e.target)
})

divB.dispatchEvent(clickAEvent)
```



## 浏览器渲染引擎干什么的，有哪些阶段

​	把静态资源转换为可视化界面



# ^_^

```js

```

