# 未看

- 掘金 - web前端面试指南与高频考题解析
  - 一面3 - CSS，一面4 - 算法（泛），一面5 - web安全，一面6 - Linux
- 幕客 - 解锁前端面试体系核心攻略 - 修言
  - **02** - LHS、RHS没懂；**03 闭包—探索词法作用域模型**；**15 手写Promise**；**16 起底 PromiseA+——决议程序**
  - **19至21 - DOM相关**；**25至26 - 浏览器渲染引擎**；**27至19 - Event Loop（浏览器和Node）**
  - **33至35 - 虚拟DOM和Fiber**；**36至38 - Vue响应式和nextTick及其他真题**
  - **39 - TCP与UDP；40至41 - HTTP；42 - 跨域；43至46 - 一些重点布局与响应式布局**
  - **47至48 - 设计模式与前端算法**
- 掘金 - 前端面试之道
  - **JS基础**：类型转换，==和===；**ES6**：原型继承和class继承，模块化，Proxy，map，filter，reduce
  - **异步**：常用定时器函数；**手写Promise**（看不懂）；**EventLoop**（看不懂）；
  - **JS进阶知识点**：手写bind，手写new，手写instanceof，为什么 0.1 + 0.2 != 0.3，垃圾回收机制
  - **JS思考题**：综合了前面的；**DevTools Tips**：一些debug技巧；
  - **浏览器基础知识点及常考面试题**：事件跨域postMessage存储；**浏览器缓存机制**
  - 13浏览器渲染原理
  - 14安全防范知识点
  - 15从 V8 中看 JS 性能优化
  - 16性能优化琐碎事
  - 17Webpack 性能优化
  - 18实现小型打包工具试读
  - 19React 和 Vue 两大框架之间的相爱相杀
  - 20Vue 常考基础知识点
  - 21Vue 常考进阶知识点
  - 22React 常考基础知识点
  - 23React 常考进阶知识点
  - 24监控
  - 25UDP
  - 26TCP
  - 27HTTP 及 TLS
  - 28HTTP/2 及 HTTP/3
  - 29输入 URL 到页面渲染的整个流程
  - 30设计模式
  - 31常见数据结构
  - 32常考算法题解析

- 幕客 - 前端框架及项目面试mp4
  - 3-6 生命周期
  - 3-16，3-17 vuex，vue-router；第四章Vue原理以后







# --- 5 ---

## 数据类型转换

```js
'' == null    // false
'' == 0        // true
[] == 0        // false or true?
[] == ''       // false or true?
[] == ![]      // false or true?
null == undefined // true
null == 0 // false
Number(null)     // 0
Number('')      // 0
parseInt('');    // NaN
{}+10           // 返回什么？
let obj = {
    [Symbol.toPrimitive]() {
        return 200;
    },
    valueOf() {
        return 300;
    },
    toString() {
        return 'Hello';
    }
}
console.log(obj + 200); // 这里打印出来是多少？
```



### 强制类型转换

​	强制类型转换方式包括 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()

**Number() 方法的强制转换规则**

- true 和 false 分别被转换为 1 和 0
- null，返回 0
- undefined，返回 NaN
- 字符串，数字和浮点数直接转换（其他进制自动转为10进制），`''` 转为0，其他返回 NaN
- Symbol，抛出错误

**Boolean() 方法的强制转换规则**

​	除了 undefined、 null、 false、 ''、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。



### 隐式类型转换

。。。。









## 自定义事件

​	事件对象不一定需要你通过触发某个具体的事件来让它“自然发生”，它也可以手动创建的：事件对象的这个特性，是我们创建自定义事件的基础，它确实非常重要。

```js
 event = new Event(typeArg, eventInit);
```

​	假设这种场景，如果我现在想实现这样一种效果：在点击A之后，B 和 C 都能感知到 A 被点击了，并且做出相应的行为

```html
<div id="divA">我是A</div>
<div id="divB">我是B</div>
<div id="divC">我是C</div>
```

​	在早年，最经典的解法就是——自定义事件。“A被点击了”这件事情，可以作为一个事件来派发出去，由 B 和 C 来监听这个事件，并执行各自身上安装的对应的处理函数。

```js
var clickA = new Event('clickA');

divB.addEventListener('clickA', function(e){
  console.log('我是小B，我感觉到了小A')
  console.log(e.target)
}) 

// A 元素的监听函数也得改造下
divA.addEventListener('click', function(){
  console.log('我是小A')
  // 注意这里 dispatch 这个动作，就是我们自己派发事件了
  divB.dispatchEvent(clickAEvent)
}) 
```



## setState同步&异步

08 don't understand - dirtyComponents - batchedUpdates - 事务流

​	setState后，newState会被存入一个pending队列，然后判断是否处于batch update这个机制中，是则保存组件于dirtyComponent中，先将需更新的组件存起来，稍后更新。否则遍历所有的dirtyCompoennts，调用updateComponent，然后去执行更新。进入更新流程后，会将 `isInsideEventHandler` 设置为 `true` 。

​	在正处于一个更新流程中调用 `setState` 并不会立即更新 `state` ，此时 `isInsideEventHandler` 为 `true`，所以会将更新放入 `dirtyComponents` 中等待稍后更新。所以setTimeout和原生事件没有被判断没有在那个batchUpdate中，不会放入 `dirtyComponent` 进行异步更新，其结果自然是同步的。

​	dirtyCompoennt就是说现在state已经被更新的组件







