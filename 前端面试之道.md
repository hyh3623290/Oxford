# 箭头函数的this

​	首先箭头函数其实是没有 `this` 的，箭头函数中的 `this` 只取决包裹箭头函数的第一个普通函数的 `this`。

​	普通函数不管我们给函数 `bind` 几次，`fn` 中的 `this` 永远由第一次 `bind` 决定



# 闭包

​	在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。



# 深浅拷贝

```js
// 浅拷贝, 只解决第一层
let a = Object.assign({}, obj)
let b = {...obj}

// 深拷贝
let b = JSON.parse(JSON.stringify(obj))
```

但是该深拷贝方法也是有局限性的：

- 会忽略 `undefined`
- 会忽略 `symbol`
- 不能序列化函数
- 不能解决循环引用的对象

所以建议`_.cloneDeep(value)`

**手写深拷贝**

```js
function deepClone(value) {
  function isObject(obj) {
    return (typeof obj === 'object' || typeof obj === 'function') && typeof obj !== 'null'
  }
  if(!isObject(value)) {
    throw new Error('非对象')
  }
  let isArray = Array.isArray(value)
  let newObj = isArray ? [...value] : { ...value }
  Reflect.ownKeys(newObj).forEach(key => {
    newObj[key] = isObject(newObj[key]) ? deepClone(newObj[key]) : newObj[key]
  })
  return newObj
}
```



# 原型

​	原型的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指回原型



# 变量提升题目

```js
var a = 10
var a
console.log(a) // 10

等价于
var a
var a
a = 10
console.log(a)

var b = 1
function b() {}
console.log(b) // 1 函数提升优先于变量提升


```

# var，let和const区别

1. 变量提升
2. 块级作用域
3. 全局使用是否会挂载到window上



# ES5继承

```js
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}

function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})

const child = new Child(1)
```



​	`Object.create()`方法创建一个新对象，第一个参数会成为被创建对象的原型对象`__proto__`，第二个参数类似`Object.defineProperties()`的第二个参数

```js
o = Object.create({a:666}, {
  // foo会成为所创建对象的数据属性
  foo: {
    writable:true,
    configurable:true,
    value: "hello"
  },
  // bar会成为所创建对象的访问器属性
  bar: {
    configurable: false,
    get: function() { return 10 },
    set: function(value) {
      console.log("Setting `o.bar` to", value);
    }
  }
});
```

# 模块化

​	ES6部分

# Proxy

​	用法 - ES6部分

​	之所以 Vue3.0 要使用 `Proxy` 替换原本的 API 原因在于 `Proxy` 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 `Proxy` 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。

# Generator

`Generator` 算是 ES6 中难理解的概念之一了，`Generator` 最大的特点就是可以控制函数的执行。在这一小节中我们不会去讲什么是 `Generator`，而是把重点放在 `Generator` 的一些容易困惑的地方。

```js
function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
let it = foo(5)
console.log(it.next())   // => {value: 6, done: false}
console.log(it.next(12)) // => {value: 8, done: false}
console.log(it.next(13)) // => {value: 42, done: true}
```

你也许会疑惑为什么会产生与你预想不同的值，接下来就让我为你逐行代码分析原因

- 首先 `Generator` 函数调用和普通函数不同，它会返回一个迭代器
- 当执行第一次 `next` 时，传参会被忽略，并且函数暂停在 `yield (x + 1)` 处，所以返回 `5 + 1 = 6`
- 当执行第二次 `next` 时，传入的参数等于上一个 `yield` 的返回值，如果你不传参，`yield` 永远返回 `undefined`。此时 `let y = 2 * 12`，所以第二个 `yield` 等于 `2 * 12 / 3 = 8`
- 当执行第三次 `next` 时，传入的参数会传递给 `z`，所以 `z = 13, x = 5, y = 24`，相加等于 `42`

# Promise

```js
const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

function MyPromise(fn) {
  const that = this
  that.state = PENDING
  that.value = null
  that.resolvedCallbacks = []
  that.rejectedCallbacks = []
  function resolve(value) {
    if (value instanceof MyPromise) {
      return value.then(resolve, reject) // ？
    }
    setTimeout(() => {
      if (that.state === PENDING) {
        that.state = RESOLVED
        that.value = value
        that.resolvedCallbacks.map(cb => cb(that.value))
      }
    }, 0)
  }
  function reject(value) {
    setTimeout(() => {
      if (that.state === PENDING) {
        that.state = REJECTED
        that.value = value
        that.rejectedCallbacks.map(cb => cb(that.value))
      }
    }, 0)
  }
  try {
    fn(resolve, reject)
  } catch (e) {
    reject(e)
  }
}
```

```js
MyPromise.prototype.then = function(onFulfilled, onRejected) {
  const that = this
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
  onRejected = typeof onRejected === 'function' ? onRejected: r => { throw r }
  if (that.state === PENDING) {
    that.resolvedCallbacks.push(onFulfilled)
    that.rejectedCallbacks.push(onRejected)
  }
  if (that.state === RESOLVED) {
    onFulfilled(that.value)
  }
  if (that.state === REJECTED) {
    onRejected(that.value)
  }
}
```





# ^_^