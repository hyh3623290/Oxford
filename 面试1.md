[toc]

# 解锁前端面试体系核心攻略



# 闭包

​	像 a、b、c 这样在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量

​	引用了自由变量的函数，就叫闭包

​	闭包就是能够读取其他函数内部变量的函数。（百度百科）



## 作用域

​	变量、函数、标识符可以被访问的区域



### 动态作用域

​	相对“冷门”，但确实有一些语言采纳的是动态作用域，如：Bash 脚本、Perl 等

​	在代码运行时完成划分，作用域链沿着它的**调用栈**往外延伸



### 词法作用域

​	在代码书写的时候完成划分，作用域链沿着它**定义的位置**往外延伸

### 如何修改词法作用域

​	eval方法

​	eval 函数的入参是一个字符串。当 eval 拿到一个字符串入参后，它会把这段字符串的内容当做一段 js 代码（不管它是不是一段 js 代码），插入自己被调用的那个位置。	



### 加餐

​	LHS、RHS，是引擎在执行代码的时候，查询变量的两种方式。



## 闭包面试真题

经典闭包+循环的题

```js
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}

console.log(i);
```

三种解决方法：

- setTimeout 函数的第三个参数会传给里面的回调函数

- 在 setTimeout 外面再套一层函数，利用这个外部函数的入参来缓存每一个循环中的 i 值：

  ```js
  var output = function (i) {
      setTimeout(function() {
          console.log(i);
      }, 1000);
  };
  
  for (var i = 0; i < 5; i++) {
      // 这里的 i 被赋值给了 output 作用域内的变量 i
      output(i);  
  }
  ```

- 利用立即执行函数的入参来缓存每一个循环中的 i 值

  ```js
  for (var i = 0; i < 5; i++) {
      // 这里的 i 被赋值给了立即执行函数作用域内的变量 j
      (function(j) {  
          setTimeout(function() {
              console.log(j);
          }, 1000);
      })(i);
  }
  ```



## 闭包的应用

1. 模拟私有变量

```js
const User = (function () {
  // 定义私有变量_password
  let _password

  class User {
    constructor(username, password) {
      // 初始化私有变量_password
      _password = password
      this.username = username
    }

    login() {
      // 这里我们增加一行 console，为了验证 login 里仍可以顺利拿到密码
      console.log(this.username, _password)
    }
  }
  return User
})()

let user = new User('xiuyan', 'xiuyan123')

console.log(user.username)
console.log(user.password)
console.log(user._password)
```

​	我们看到不管是 password，还是 _password，都被好好地保护在了 User 这个立即执行函数的内部，并且此时打印user实例发现只有username和login属性（login属性在`__proto__`上）

2. 偏函数与柯里化

​    柯里化是把接受 n 个参数的 1 个函数改造为只接受 1个参数的 n 个互相嵌套的函数的过程。也就是 `fn (a, b, c)`会变成 `fn (a)(b)(c)`

​	偏函数应用是不强调 “单参数” 这个概念的。它的目标仅仅是把函数的入参拆解为两部分。



# 垃圾回收机制

​	JS 的垃圾收集器就会对变量做 “巡检”。当它判断一个变量不再被需要之后，它就会把这个变量所占用的内存空间给释放掉，这个过程叫做垃圾回收。

## 引用计数法

​	内存中的每一个值都会对应一个数字（引用计数）。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。

​	无法解决循环引用的问题

## 标记清除法

- 标记阶段：垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为 “可抵达”。
- 清除阶段： 没有被标记为 “可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除



## 闭包与内存泄漏

​	在 V8 中，一旦不同的作用域位于同一个父级作用域下，那么它们会共享这个父级作用域。（V8 引擎）



## 内存泄漏成因分析

1. “手滑” 导致的全局变量

```js
function test() {
  me = 'xiuyan'
}
// 导致这个 me 被默默地挂载到全局对象上, 永远无法被清除
```

2. 忘记清除的 setInterval 和 setTimeout
3. 清除不当的 DOM

```js
const myDiv = document.getElementById('myDiv')

function handleMyDiv() {
  一些与myDiv相关的逻辑
}
handleMyDiv()

document.body.removeChild(document.getElementById('myDiv'));
// myDiv 这个变量对这个 DOM 的引用仍然存在
```



# this指向

​	注意`b = a.fn; b()`这种情况，有时候复杂一点可能会看不出来或者搞混了

技巧：下面三种情况指向window（不过注意不能是箭头函数）

- 立即执行函数（IIFE）
- setTimeout 中传入的函数
- setInterval 中传入的函数

​	如果是箭头函数的话就只认词法作用域，this和你如何调用它无关，而是由你书写它的位置决定

# 实现call，apply，bind

```js
fn.myCall(obj, 1, 2)
// fn.mycall -> mycall里的this是fn -> 给obj加一个fn方法 -> 执行obj.fn即可绑定this
// 最后删除这个obj的fn方法
```

```js
Function.prototype.myCall = function(context, ...args) {
  // step1: 把函数挂到目标对象上（这里的 this 就是我们要改造的的那个函数）
  context.func = this
  // step2: 执行函数
  context.func(...args)
  // step3: 删除 step1 中挂到目标对象上的函数，把目标对象”完璧归赵”
  delete context.func
}
```



# 执行上下文

从定义上理解，是 “执行代码的环境”。分为三类

- 全局上下文 —— 全局代码所处的环境，不在函数中的代码都在全局执行上下文中
- 函数上下文 —— 在函数调用时创建的上下文
- Eval 执行上下文





# 手写Promise

```js
function CutePromise(executor) {
  // value 记录异步任务成功的执行结果
  this.value = null;
  // reason 记录异步任务失败的原因
  this.reason = null;
  // status 记录当前状态，初始化是 pending
  this.status = 'pending';

  // 缓存两个队列，维护 resolved 和 rejected 各自对应的处理函数
  this.onResolvedQueue = [];
  this.onRejectedQueue = [];

  // 把 this 存下来，后面会用到
  var self = this;

  // 定义 resolve 函数
  function resolve(value) {
    // 如果是 pending 状态，直接返回
    if (self.status !== 'pending') {
      return;
    }
    // 异步任务成功，把结果赋值给 value
    self.value = value;
    // 当前状态切换为 resolved
    self.status = 'resolved';
    // 批量执行 resolved 队列里的任务
    self.onResolvedQueue.forEach(resolved => resolved(self.value));
  }

  // 定义 reject 函数
  function reject(reason) {
    // 如果是 pending 状态，直接返回
    if (self.status !== 'pending') {
      return;
    }
    // 异步任务失败，把结果赋值给 value
    self.reason = reason;
    // 当前状态切换为 rejected
    self.status = 'rejected';
    // 用 setTimeout 延迟队列任务的执行
    // 批量执行 rejected 队列里的任务
    self.onRejectedQueue.forEach(rejected => rejected(self.reason));
  }

  // 把 resolve 和 reject 能力赋予执行器
  executor(resolve, reject);
}

function resolutionProcedure(promise2, x, resolve, reject) {
  // 这里 hasCalled 这个标识，是为了确保 resolve、reject 不要被重复执行
  let hasCalled;
  if (x === promise2) {
    // 决议程序规范：如果 resolve 结果和 promise2相同则reject，这是为了避免死循环
    return reject(new TypeError('为避免死循环，此处抛错'));
  } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    // 决议程序规范：如果x是一个对象或者函数，则需要额外处理下
    try {
      // 首先是看它有没有 then 方法（是不是 thenable 对象）
      let then = x.then;
      // 如果是 thenable 对象，则将promise的then方法指向x.then。
      if (typeof then === 'function') {
        // 如果 then 是是一个函数，那么用x为this来调用它，第一个参数为 resolvePromise，第二个参数为rejectPromise
        then.call(x, y => {
          // 如果已经被 resolve/reject 过了，那么直接 return
          if (hasCalled) return;
          hasCalled = true;
          // 进入决议程序（递归调用自身）
          resolutionProcedure(promise2, y, resolve, reject);
        }, err => {
          // 这里 hascalled 用法和上面意思一样
          if (hasCalled) return;
          hasCalled = true;
          reject(err);
        });
      } else {
        // 如果then不是function，用x为参数执行promise
        resolve(x);
      }
    } catch (e) {
      if (hasCalled) return;
      hasCalled = true;
      reject(e);
    }
  } else {
    // 如果x不是一个object或者function，用x为参数执行promise
    resolve(x);
  }
}

// then 方法接收两个函数作为入参（可选）
CutePromise.prototype.then = function (onResolved, onRejected) {

  // 注意，onResolved 和 onRejected必须是函数；如果不是，我们此处用一个透传来兜底
  if (typeof onResolved !== 'function') {
    onResolved = function (x) { return x };
  }
  if (typeof onRejected !== 'function') {
    onRejected = function (e) { throw e };
  }

  // 依然是保存 this
  var self = this;
  // 这个变量用来存返回值 x
  let x

  // resolve态的处理函数
  function resolveByStatus(resolve, reject) {
    // 包装成异步任务，确保决议程序在 then 后执行
    setTimeout(function () {
      try {
        // 返回值赋值给 x
        x = onResolved(self.value);
        // 进入决议程序
        resolutionProcedure(promise2, x, resolve, reject);
      } catch (e) {
        // 如果onResolved或者onRejected抛出异常error，则promise2必须被rejected，用error做reason
        reject(e);
      }
    });
  }

  // reject态的处理函数
  function rejectByStatus(resolve, reject) {
    // 包装成异步任务，确保决议程序在 then 后执行
    setTimeout(function () {
      try {
        // 返回值赋值给 x
        x = onRejected(self.reason);
        // 进入决议程序
        resolutionProcedure(promise2, x, resolve, reject);
      } catch (e) {
        reject(e);
      }
    });
  }


  // 注意，这里我们不能再简单粗暴 return this 了，需要 return 一个符合规范的 Promise 对象
  var promise2 = new CutePromise(function (resolve, reject) {
    // 判断状态，分配对应的处理函数
    if (self.status === 'resolved') {
      // resolve 处理函数
      resolveByStatus(resolve, reject);
    } else if (self.status === 'rejected') {
      // reject 处理函数
      rejectByStatus(resolve, reject);
    } else if (self.status === 'pending') {
      // 若是 pending ，则将任务推入对应队列
      self.onResolvedQueue.push(function () {
        resolveByStatus(resolve, reject);
      });
      self.onRejectedQueue.push(function () {
        rejectByStatus(resolve, reject);
      });
    }
  });

  // 把包装好的 promise2 return 掉
  return promise2;
};
```

# 暂时性死区

​	只要在let，const之前使用变量就会报错

```js
var me = 'xiuyan';
{
	me = 'bear';
	let me;
}
// 报错
```



# 类数组转换

类数组定义

1. 它必须是一个对象
2. 它有 length 属性

将如下的类数组对象转换为数组，你能想到哪些方法？

```js
const arrayLike = {0: 'Bob', 1: 'Lucy', 2: 'Daisy', length: 3 }
```

- Array原型上的slice方法—— 这个方法如果不传参数的话会返回原数组的一个拷贝，因此可以用此方法转换类数组到数组：

```js
const arr = Array.prototype.slice.call(arrayLike);
```

- Array.from方法——这是 ES6 新增的一个数组方法，专门用来把类数组转为数组：

```js
const arr = Array.from(arrayLike);
```

- 扩展运算符——"…"也可以把类数组对象转换为数组，前提是这个类数组对象上部署了遍历器接口。在这个例子中，arrayLike 没有部署遍历器接口，所以这条路走不通。但一些对象，比如函数内部的 arguments 变量（它也是类数组对象），就满足条件，可以用这种方法来转换：

```js
function demo() {
  console.log('转换后的 arguments 对象：', [...arguments])
} 

demo(1, 2, 3, 4) // 转换后的 arguments 对象：[1, 2, 3, 4]
```



# 事件

## 事件流

​	它描述的是事件在页面中传播的顺序

W3C 标准约定了一个事件的传播过程要经过以下三个阶段：

1. 事件捕获阶段，从最外层元素document开始
2. 目标阶段
3. 事件冒泡阶段，从目标元素到document

​    在这个过程中，事件处理函数都会被触发



## 属性

​	在event事件对象中，有一些属性和方法

### currentTarget

​	它记录了事件当下正在被哪个元素接收，即”正在经过哪个元素“。这个元素是一直在改变的，因为事件的传播毕竟是个层层穿梭的过程。

​	如果事件处理程序绑定的元素，与具体的触发元素是一样的，那么函数中的 `this`、event.`currentTarget`、和 event.`target` 三个值是相同的。我们可以以此为依据，判断当前的元素是否就是目标元素。



### target

​	指触发事件的具体目标，也就是最具体的那个元素，是事件的真正来源。

​	就算事件处理程序没有绑定在目标元素上、而是绑定在了目标元素的父元素上，只要它是由内部的目标元素冒泡到父容器上触发的，那么我们仍然可以通过 target 来感知到目标元素才是事件真实的来源。

### preventDefault

​	这个方法用于阻止特定事件的默认行为，如 `a` 标签的跳转等。

```js
e.preventDefault();
```

### stopPropagation

​	这个方法用于终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。

```js
e.stopPropagation();
```

​	有时我们不希望一个事件的触发带来“一石激起千层浪”的效果，希望把它的影响面控制在目标元素这个范围内。这种情况下，千万别忘了 stopPropagation。

### 事件对象，是可以手动创建的

​	事件对象不一定需要你通过触发某个具体的事件来让它“自然发生”，它也可以手动创建的：

​	我们可以借助 Event() 构造函数, 来创建一个新的事件对象 Event。

```js
 event = new Event(typeArg, eventInit);
```

​	事件对象的这个特性，是我们创建自定义事件的基础——可能一些同学对自定义事件还比较陌生，但它确实非常重要。在四五年前，自定义事件就已经是考察一个前端是否资深的重要标准。随着前端技术的蓬勃发展，对资深前端的要求不断提高，自定义事件的能力变成了基础层次的能力，但它的不可或缺性仍然不可改变。

```js
var clickAEvent = new Event('clickA');

// 获取 divB 元素
var divB = document.getElementById('divB')
// divB 监听 clickA 事件
divB.addEventListener('clickA', function (e) {
  console.log('我是小B，我感觉到了小A')
  console.log(e.target)
})
// 注意这里 dispatch 这个动作，就是我们自己派发事件了
divB.dispatchEvent(clickAEvent)
```



## 事件代理

​	事件代理，又叫事件委托。

​	点击任何 一个 li，是不是这个点击事件都会被冒到它们共同的爹地—— ul 元素上去？那我能不能让 ul 来做这个事儿？答案是 能，因为 ul 不仅能感知到这个冒上来的事件，它还可以通过 e.target 拿到实际触发事件的那个元素，做到无缝代 理：

```js
ul.addEventListener('click', function(e){
	console.log(e.target.innerHTML)
})
```

​	大家谨记，e.target 就是指触发事件的具体目标，它记录着事件的源头。所以说，不管咱们的监听函数在哪一层执 行，只要我拿到这个 e.target，就相当于拿到了真正触发事件的那个元素。拿到这个元素后，我们完全可以模拟出 它的行为，实现无差别的监听效果。

# 节流

​	第一个人说了算

​	所谓的“节流”，是通过在一段时间内**无视后来产生的回调请求**来实现的。

​	每当用户触发了一次 scroll 事件，我们就为这个触发操作开启计时器。一段时间内，后续所有的 scroll 事件都会被当作“一辆车的乘客”——它们无法触发新的 scroll 回调。直到“一段时间”到了，第一次触发的 scroll 事件对应的回调才会执行，而“一段时间内”触发的后续的 scroll 回调都会被节流阀无视掉。

```js
// fn是我们需要包装的事件回调, interval是时间间隔的阈值
function throttle(fn, interval) {
  // last为上一次触发回调的时间
  let last = 0

  // 将throttle处理结果当作函数返回
  return function () {
    // 保留调用时的this上下文
    let context = this
    // 保留调用时传入的参数
    let args = arguments
    // 记录本次触发回调的时间
    let now = +new Date()

    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值
    if (now - last >= interval) {
      // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调
      last = now;
      fn.apply(context, args);
    }
  }
}
// 用throttle来包装scroll的回调
const better_scroll = throttle(() => console.log('触发了滚动事件'), 1000)
document.addEventListener('scroll', better_scroll)
```



# 防抖

​	防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。

```js
// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间
function debounce(fn, delay) {
  // 定时器
  let timer = null

  // 将debounce处理结果当作函数返回
  return function () {
    // 保留调用时的this上下文
    let context = this
    // 保留调用时传入的参数
    let args = arguments
    // 每次事件被触发时，都去清除之前的旧定时器
    if (timer) {
      clearTimeout(timer)
    }
    // 设立新定时器
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, delay)
  }
}
// 用debounce来包装scroll的回调
const better_scroll = debounce(() => console.log('触发了滚动事件'), 1000)
document.addEventListener('scroll', better_scroll)
```



# 浏览器渲染引擎

​	浏览器的渲染引擎承载着把静态资源转换为可视化界面的任务

**1. HTML解析**

​	浏览器不能够直接理解 HTML，它首先会把它转化成自己能理解的 DOM 树。也就是浏览器对HTML文档进行解析，并在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。

**2. CSS解析**
	同样也需要把它处理成自己能理解的 CSSOM 树

**3. 样式与结构合并**
	将样式信息和文档结构合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。

**4. 布局阶段**
	然后就根据这个渲染树，以盒子模型的形式写入文档流。页面中所有元素的相对位置信息，大小等信息均在这一步得到计算

**5. 页面绘制**
	在这一步中浏览器会根据我们前面处理出来的结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。



# 重绘与重排

​	在页面初始化完成后，我们可能会通过CSS、JS来对页面中的元素进行修改，这些修改会重新触发页面的一部分生命周期，进而带来性能上的开销。

​	重走页面生命周期的这个过程，有两种主要的形式——重排与重绘。



**1.重排**

​	当我们的操作引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是重排（也叫回流）。

​	此时就会从构建dom开始重新执行

**改变 DOM 树的结构**

​	这里主要指的是节点的增减、移动等操作。

**获取一些特定属性的值（重要）**

​	如offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 等属性

​	这些属性有一个共性，就是需要通过**即时计算**得到。因此浏览器为了获取这些值，也会进行回流。



**2.重绘**

​	当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。



# EventLoop

## 浏览器

### 函数调用栈

​	当引擎第一次遇到 JS 代码时，会产生一个全局执行上下文并压入调用栈。后面每遇到一个函数调用，就会往栈中压入一个新的函数上下文。JS引擎会执行栈顶的函数，执行完毕后，弹出对应的上下文

​	等待着被推入调用栈的这个队列，就叫做“**任务队列**”。

### 宏任务

​	常见的 macro-task 比如： setTimeout、setInterval、 setImmediate（Node）、 script（整体代码）、I/O 操作、UI 渲染等

### 微任务

​	常见的 micro-task 比如: process.nextTick（Node）、Promise、MutationObserver 等



​	需要注意的是：当 macro-task 出队时，任务是**一个一个**执行的；而 micro-task 出队时，任务是**一队一队**执行的

## Node

？28，29



# React

## 新旧生命周期

​	分16.3之前与16.4之后

​	都可以分为挂载阶段，更新阶段，卸载阶段

​	挂载阶段首先是constructor，进行初始化操作。

​	之后是`componentWillMount`，已被React16**废弃**。

​	再接下来是render方法，这个是唯一一个必须要实现的方法，一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上。

​	最后是`componentDidMount`，会在组件挂载后（插入 DOM 树中后）立即调用，也就标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。

​	更新阶段分为state和props的更新，props变化导致的更新多一个 componentWillReceiveProps，也已经被**废弃**。

​	接下来是shouldComponentUpdate，它会接收两个参数：nextProps, nextState，返回false则不会更新

​	然后是componentWillUpdate，会在渲染之前调用，也已被**废弃**，过去，我们可能希望能在这个阶段去收集一些必要的信息，比如更新前的 DOM 信息等等，现在可以用getSnapshotBeforeUpdate代替

​	最后componentDidUpdate 会在UI更新后会被立即调用

​	新生命周期的话和Fiber有关，多了两个getDerivedStateFromProps和getSnapshotBeforeUpdate，前者在render之前调用，它接收 props 和 state 两个入参。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。

​	后者必须有返回值——它的返回值会作为第三个参数传递给 `componentDidUpdate`。注意，因为走到这一步时，React 已经更新上了所有状态，所以新状态可以通过 this.props、this.state 获取。所以结合两个入参，我们可以拿到所有的新旧状态。大家知道，一些场景下，我们是需要对更新前后的 DOM 节点信息作一些对比或是处理的。比如说我想知道更新前后，某一个 div 的位置移动了多少，以此来决定是否来把它矫正回原位、或者是直接帮它移动一个更合适的距离呢？这种情况下，用 getSnapshotBeforeUpdate 就再合适不过啦~



## React组件通信

​	首先最简单的是父子，父传子的话就是props，子传父的话就是调用父亲传进来的函数，把数据通过函数入参的形式传进去。如果是兄弟组件的话可以通过共同的父组件来进行通信。如果是嵌套很多层的情况下一般用context，如果是任意组件的话就可以用Event Bus或者Redux

​	context怎么用，就是通过createContext方法，他会有Provider和Consumer。



## React 组件设计模式

1. 什么是HoC（Higher-Order Component）？适用于什么场景？

2. 什么时候应该选择用class实现一个组件，什么时候应该用一个函数实现一个组件？

3. 你喜欢React Stateless组件吗？为什么？（发散题目 ）

## setState 深入

1. 当组件的setState函数被调用之后，会发生什么？

2. setState可以接受函数为参数吗？有什么作用？

## 事件系统

React事件机制是怎样的？为什么它要定义一套事件体系？

## React 底层原理

1. 为什么我们利用循环产生的组件中要用上key这个特殊的prop？

2. 什么是Fiber？是为了解决什么问题？



## 虚拟DOM

​	模板渲染带来的性能问题，就这样被 Virtual DOM 完美地解决了，模版的话修改一处，整个都需要被重新渲染，使用virtual dom + diff 可已最小化修改



## diff 算法

​	这个“找不同”的过程——也叫调和过程（Reconciliation）

​	对两颗树形数据结构间的不同，需要递归逐个对比两棵树的节点，其复杂度是 O(n^3)。

​	React 团队没有采纳这种愚蠢的算法。他们采纳了一种复杂度仅为 O(n）的 `diff` 算法

diff算法主要基于三个假设：

1. 相同的组件有着相同的 DOM 结构，不同的组件有着不同的 DOM 结构
2. 位于同一层次的一组子节点，它们之间可以通过唯一的 id 进行区分
3. DOM 结构中，跨层级的节点操作非常少，可以忽略不计

​    根据这样的假设，首先，当我们考虑两棵树的“不同”时，可以一层一层来考虑，也就是“逐层对比”。如果是同一层次的，有时候可能只是位置变化，但是该节点还是可以复用，所以可以用key来辅助



## Fiber

​	帮我们实现异步渲染

​	面对“单个任务耗时过长”这个问题，工程师们的思路是，把一个庞大的任务拆分成 N 多个微小的任务

​	这个拆分的结果，就叫 Fiber。它代表着一个单位的工作，也是接受调度的最小单元。

​	**render/reconcilition**：调和阶段——“找不同”的过程。这个过程里，React在内存中做计算，确认所有的更新行为。

这个过程涉及的生命周期有：

1. [UNSAFE_]componentWillMount (已废弃)；
2. [UNSAFE_]componentWillReceiveProps (已废弃)；
3. getDerivedStateFromProps；
4. shouldComponentUpdate；
5. [UNSAFE_]componentWillUpdate (已废弃)；
6. render。

**commit**： 执行调和阶段的计算结果，真正地去更新 DOM ，这个过程涉及的生命周期有：

1. getSnapshotBeforeUpdate；
2. componentDidMount；
3. componentDidUpdate；
4. componentWillUnmount。

​	由于调和阶段的生命周期逻辑是单纯的 js 计算，所有的工作都在内存里进行，**不涉及真实 DOM 操作**，也就是说你打断执行也好、重复执行也罢，用户都是不感知的，只要你最后能 commit 出正确的 DOM 更新就好。这里硬要说的话，有一个编码层面的坑需要注意一下：在调和阶段的生命周期里，不要尝试写入一些你期望它只执行一次的逻辑，它可不保证到底会给你执行多少次。



# Vue

## 响应式原理

​	Vue 会对传入的 data 做处理：为每一个属性添加 getter 和 setter，通过 **Object.defineProperty** 这个方法

​	同时每一个 Vue 组件实例，都对应着一个 watcher 实例；由于 render 函数的执行依赖于数据的读取，因此渲染时必定会读取 data 属性进而触发其对应的 getter 方法。getter 方法被调用后，会通知到 watcher，watcher 就会把这些 getter 方法被触发的属性记录为“依赖”——这一过程，就是大家常常听到的“**依赖收集**”过程。

​	如果 data 发生了更新，也就是说被“写”了，此时对应属性的 setter 方法就会被触发。setter 也会去通知 watcher，告诉它“我改变了”。watcher 拿到消息后，立刻跑去告诉 render：“data 变了，你也给我跟着变！”。由此去触发一个 re-render 的过程、与数据更新相关的组件会重新渲染。



在源码层次，大家需要把握好这三个角色：

- Observer：处理 data 的家伙。它会给 data 安装 getter 和 setter，这些安装上的逻辑会联动 Dep 去完成依赖收集和更新的派发；
- Dep：实际通知 Watcher 的人。在 getter 和 setter 逻辑中，正是通过调度 Dep 来完成信息的收集、以及和 Watcher 间的通信；
- Watcher：Watcher 被通知之后，就会通知 render、进而触发重渲染了。



## nexTick

​	原理源码 - 37



## 生命周期

​	首先是beforeCreate，实例初始化以后首先触发的钩子，在这一步，所有的数据还没有被初始化，接下来是created，此时数据初始化已经完成，可以访问，不过由于dom未挂载，组件仍不可见，剩余的跟面试之道无差。

​	keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。

​	如果你为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、actived。同时，beforeDestroy 和 destroyed 就不会再被触发了——毕竟组件不会被真正销毁。

​	当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 actived。



## 路由

​	早期，一个 url 对应一个页面，切换页面的话页面就会刷新，Ajax出现后，就出现了SPA（单页面应用），不刷新页面即可更新页面内容。只有一个URL会暴露很多问题：

1. 没有办法记住你的操作，一刷新全都没了，也不知道当前页面进展到了哪一步
2. 由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息

​    所以就有了前端路由，前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步，为 SPA 中的各个视图匹配一个唯一标识。

​	主要有两种形式，hash和history，只要能实现修改和监听即齐活了。

**URL 后的 hash 值**

```js
// 直接去修改当前 URL 的 hash 值
window.location.hash = 'index'; 

// 监听 “hashchange”事件, 捕捉 hash 值的变化
window.addEventListener('hashchange', function(event){ 
  ...
},false)
```

**浏览器的 history API**

​	从 HTML5 开始，浏览器支持了 pushState 和 replaceState 两个 API，允许我们对浏览历史进行修改和新增

```js
 // 向浏览历史中追加一条记录
history.pushState(data[,title][,url]);
 // 修改（替换）当前页在浏览历史中的信息
history.replaceState(data[,title][,url]);

// 通过监听 popstate 事件感知修改
window.addEventListener('popstate', function(e) {
  console.log(e)
});
```

​	每当浏览历史发生变化，popstate 事件都会被触发。**注意这里有个坑**：go、forward 和 back 等方法的调用确实会触发 popstate，但是 **pushState 和 replaceState 不会**

​	这个缺憾问题也不大，我们一般通过自定义事件（可复习我们前面的事件专题）和全局事件总线（后续设计模式专题会讲解）来实现。

**注意：上述 history API 均不会导致页面的刷新。**

## MVVM

​	38

# TCP 与 UDP

​	39

# HTTP

## HTTP状态码

- **1xx**：成功接收了请求，但是处理过程还没结束，需要客户端再抛出一个请求才能完成整个过程。这个比较少见，大家了解即可。
- **2xx**：表示成功接收请求、并且已经处理完毕。其中需要重点关注下面这个码：
  - 200 OK，标识客户端的请求已经被服务器正确处理
- **3xx**：表示服务器虽然也处理了你的请求，但客户端还需要进一步的工作，才可以完成请求。其中需要大家重点关注的是：
  - 301：永久性重定向，表示资源已被分配了新的 URL
  - 302：临时性重定向，表示资源临时被分配了新的 URL
  - 304，表示服务器校验后发现资源没有改变，提醒客户端直接走缓存来取资源
- **4xx**：客户端错误，意味着请求出错了。需要关注的重点错误码是：
  - 400：请求报文存在语法错误
  - 403：对请求资源的访问被服务器拒绝（多半是没权限）
  - 404，资源不存在，可能是你的路径不对，也可能是这个资源在服务端已经被下掉了
- **5xx**：服务器错误，意味着服务器内部的程序处理有问题。需要关注的重点错误码是：
  - 500：服务器在接受请求后进行处理的过程中，发生了内部错误
  - 502：网关错误
  - 504：网关超时

## HTTP 请求方法速记

HTTP 协议常考的请求方法有 GET、POST、HEAD、PUT、DELETE、OPTIONS。

- **GET 方法**：仅用作数据的读取，请求参数以query的形式附加
- **POST 方法**：创建新资源或修改现有资源，请求参数以body的形式传递
- **HEAD 方法**：只请求页面的首部、不请求页面内容。它允许我们单纯获取服务器的响应头信息。
- **PUT 方法**：PUT 在能力上和 POST 类似，区别在于 PUT 的 URI 指向是具体的某个资源，而不能指向资源集合。同时 PUT 对资源的修改是幂等的。
- **DELETE方法**：用于删除指定的资源
- **OPTIONS方法**：用于获取指定服务能够支持的通信选项。

HTTP 协议是无状态的，这个“无状态”到底是指什么呢？

与其说是“无状态”，不如说是“无记忆”。这个 HTTP 协议呀，心非常大，请求与请求之间，是不关心对方的情况的。也就是说你上一秒出去一个 A 请求，下一秒出去一个 B 请求，那么 B 是完全感知不到 A 请求曾经存在过的，更别提了解 A 请求的内容了。总之，两个请求间**毫无瓜葛**。

那么如果我们想维持状态信息，该怎么办呢？两个思路：cookie 和 session。

- **cookie**：cookie 是存储在浏览器的小段文本，会在浏览器每次向同一服务器再发起请求时被携带并发送到服务器上。我们可以把状态信息放在cookie里，带给服务器。
- **session**：session 是存储在服务器的用户数据。浏览器第一次向服务器发起请求时，服务器会为当前会话创建一个session，并且把对应的 session-id 写入 cookie 中，用来标识 session。此后，每次用户的请求都会携带一个包含了 session-id 的 cookie，服务器解析出了 session-id，便能定位到用户的用户信息。

## HTTP 的发展史

​	40

## HTTPS

​	41

## 跨域解决方案

​    42

# 垂直水平居中

1. 绝对定位方案

   div 盒子的宽高提前已知，

```less
#container {
  position: relative
}
div {
  width: 200px;
  height: 200px;
  background-color: red;
  position: absolute; // 1
  left: 50%; // 2
  top: 50%;// 3
  margin-left: -100px; // 4
  margin-top: -100px; // 5
}
```

​	绝对定位的基准线是元素的左侧边缘和顶部边缘，因此会偏右。margin-left 设为负值，可以让元素相对于自己原有的位置向左移动相应的距离，margin-top 同理。元素就会相对于它原来的位置分别向左和向上移动自身宽/高的一半距离。如此，我们就可以弥补元素中心到元素左侧边缘和元素顶部边缘的差距了



# 1px问题

​	43

# BFC

​	44

# CSS工程化

​	44 预处理器，PostCSS，WebpackCSS

# 响应式布局

​	45 viewport，rem，em

​	46 媒体查询，rem，vw，vh，高清方案，

# 设计模式

​	47

# 前端算法

​	48

# ^_^