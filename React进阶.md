# Diff算法

​	找不同的过程，就是调和过程Reconciliation。

## 三个假设

1. 相同的组件有着相同的 DOM 结构，不同的组件有着不同的 DOM 结构。
2. 位于同一层次的一组子节点，它们之间可以通过唯一的 id 进行区分
3. DOM 结构中，跨层级的节点操作非常少，可以忽略不计

## 过程

​	首先逐层对比，当对比两棵树时，`diff` 算法会优先比较两棵树的根节点，如果它们的类型不同，比如说之前是 div，现在变成 p 了，那么就认为这两棵树完全不同，这是两个完全不同的组件。因此也没有必要再往下再比对子节点了，直接把 div 删掉，重建为 p。也就是卸载旧组件、挂载新组件。若根节点类型相同，React 才会认为“你没变，你还是那个组件”。接下来，在保留这个组件的基础上，检查其属性的变化，然后根据属性变化的情况去更新组件。

​	数组动态生成的组件，可以用key

【练习 1】你觉得 Virtual DOM 好在哪

​	以前使用模板的时候

```php+HTML
<table>
  {% students.forEach(function(student){ %}
  <tr>
    <td>{% student.name %}</td>
    <td>{% student.age %}</td>
    </tr>
  {% }); %}
</table>
```

​	模板会帮我们做什么呢？它会把你的 students 这个数据源读进去，塞到上面这段 template 代码里，把它们融合在一起，吐出一段目标 HTML 给你。然后这段 HTML 代码就可以直接被拿去渲染到页面上，成为 DOM。

​	这个过程差不多是这样：

```js
// 数据和模板融合出 HTML 代码
var targetDOM = template({data: students})
// 添加到页面中去
document.body.appendChild(targetDOM)
```

​	本来我只是想改 Maria 的名字，现在整个表格都需要被重新渲染。DOM 操作的范围，从小小的一个表格字段位，扩大到了整个表格。这不合理。

​	相比之下，虚拟 DOM 方案每次只更新必要的 DOM，虽然它增加了 diff 过程。但增加的是 js 计算，换来的可是 DOM 开销，这可是杠杆撬地球一般的操作。。。所以说，这种情况下，我们会认为虚拟 DOM 从性能上来讲会更合适。（并不是比直接操作 DOM 更快）。不用操心 DOM 细节



# Fiber

​	Fiber 是 React16 引入的一种新的调和引擎。

​	由于调和阶段的生命周期逻辑是单纯的 js 计算，所有的工作都在内存里进行，不涉及真实 DOM 操作，也就是说你打断执行也好、重复执行也罢，用户都是不感知的，只要你最后能 commit 出正确的 DOM 更新就好。这里硬要说的话，有一个编码层面的坑需要注意一下：在调和阶段的生命周期里，不要尝试写入一些你期望它只执行一次的逻辑，它可不保证到底会给你执行多少次。

