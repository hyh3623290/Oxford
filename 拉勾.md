[toc]

# JavaScript异步编程

## Generator

```js
function *foo() {
  yield 'foo' // 随时使用这个关键字向外返回一个值，但不像return立即结束，而是暂停函数的执行
}
const g = foo() // 调用它不会立即执行，而是得到一个生成器对象
const res = g.next() // 这时候才开始执行, 并拿到返回值
const a = g.next('bar') // 参数会代替yield的返回值
```



# TypeScript

```js
yarn add typescript --dev

在node_modules/.bin目录下有个tsc，可以帮我们编译typescript代码
```



# React

## virtual dom 及 diff

### createElement

```js
function createElement(type, props, ...children) {
  const childElements = [].concat(...children).reduce((result, child) => {
    if(child !== false && child !== true && child !== null) {
      if(child instanceof Object) {
        result.push(child)
      } else {
        result.push(createElement('text', { textContent: child }))
      }
    }
    return result
  }, [])
  return {
    type,
    props: Object.assign({ children: childElements }, props),
    children: childElements
  }
}

返回虚拟dom
处理children, 移除null和布尔值, 处理文本节点
将children挂到props上
```

​	这样jsx就会自动被执行createElement方法，我们就会拿到createElement的返回结果，就是一个virtual dom对象



### render

​	把vdom转换为真实dom ，`ReactDOM.render(virtualDOM, container)`

```js
function render(virtualDOM, container, oldDOM = container.firstChild) {
  diff(virtualDOM, container, oldDOM)
}
/*
	直接进行diff，后续内容在diff里做
*/

function diff(virtualDOM, container, oldDOM) {
  const oldVirtualDOM = oldDOM && oldDOM._virtualDOM
  if(!oldDOM) {
    mountElement(virtualDOM, container)
  } else if(oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
    if(virtualDOM.type === "text") {
      updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)
    } else {
      // 更新元素节点属性
      updateNodeElement(oldDOM, virtualDOM, oldVirtualDOM)
    }
    virtualDOM.children.forEach((child, i) => {
      diff(child, oldDOM, oldDOM.childNodes[i])
    })
  }
}
/**
 * 如果oldDOM不存在，直接将虚拟dom转为真实dom挂载
 *  如果存在就要开始比对了
 *    首先如果是节点类型一样的情况下
 *      如果是文本就更新文本节点，元素就更新元素节点
 */

function updateTextNode(virtualDOM, oldVirtualDOM, oldDOM) {
  if(virtualDOM.props.textContent !== oldVirtualDOM.props.textContent) {
    oldDOM.textContent = virtualDOM.props.textContent
    oldDOM._virtualDOM = virtualDOM
  }
}
/**
 * 如果textContent不一致，直接更新oldDOM的textContent
 * 记得把新的虚拟dom继续放到dom元素上以备下次diff
 */

function isFunction(virtualDOM) {
  return virtualDOM && typeof virtualDOM.type === "function"
}
/**
 * 判断是否是一个组件
 * 如果virtualDOM的type是函数类型说明是
 */

function mountElement(virtualDOM, container) {
  if(isFunction(virtualDOM)) {
    mountComponent(virtualDOM, container)
  } else {
    mountNativeElement(virtualDOM, container)
  }
}
/**
 * 如果是组件调用组件方法
 * 如果是普通元素调用普通元素方法
 */

function mountNativeElement(virtualDOM, container) {
  let newElement = createDOMElement(virtualDOM)
  container.appendChild(newElement)
}
/**
 * 挂载普通jsx元素
 *  调用createDOMElement返回真实dom并插入container
 */

function createDOMElement(virtualDOM) {
  let newElement = null
  if(virtualDOM.type === "text") {
    newElement = document.createTextNode(virtualDOM.props.textContent)
  } else {
    newElement = document.createElement(virtualDOM.type)
    updateNodeElement(newElement, virtualDOM)
  }
  // 存放旧的vdom
  newElement._virtualDOM = virtualDOM
  virtualDOM.children.forEach(child => {
    mountElement(child, newElement)
  })
  return newElement
}

function updateNodeElement(newElement, virtualDOM, oldVirtualDOM = {}) {
  const newProps = virtualDOM.props || {}
  const oldProps = oldVirtualDOM.props || {}
  // 更新属性
  Object.keys(newProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if(newPropsValue !== oldPropsValue) {
      if(propName.slice(0,2) === 'on') {
        const eventName = propName.toLowerCase().slice(2)
        newElement.addEventListener(eventName, newPropsValue)
        if(oldPropsValue) {
          newElement.removeEventListener(eventName, oldPropsValue)
        }
      } else if(propName === "value" || propName === "checked") {
        // value || checked 不能用setAttribute设置
        newElement[propName] = newPropsValue
      } else if(propName !== 'children') {
        if(propName === "className") {
          newElement.setAttributes('class', newPropsValue)
        } else {
          newElement.setAttributes(propName, newPropsValue)
        }
      }
    }
  })
  // 判断属性被删除的情况，old里面有，new里面没有
  Object.keys(oldProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if(!newPropsValue) {
      // 属性被删除了
      if(propName.slice(0, 2) === 'on') {
        const eventName = propName.toLowerCase().slice(2)
        newElement.removeEventListener(eventName, oldPropsValue)
      } else if(propName !== "children") {
        newElement.removeAttribute(propName)
      }
    }
  })
}

function mountComponent(virtualDOM, container) {
  const nextVirtualDOM = null
  if(isFunctionComponent(virtualDOM)) {
    // 函数组件
    nextVirtualDOM = buildFunctionComponent(virtualDOM)
  } else {
    // 类组件，原型上面有render方法
    nextVirtualDOM = buildClassComponent(virtualDOM)
  }
  if(isFunction(nextVirtualDOM)) {
    mountComponent(nextVirtualDOM, container)
  } else {
    mountNativeElement(nextVirtualDOM, container)
  }
  
}

function isFunctionComponent(virtualDOM) {
  const type = virtualDOM.type
  return type && isFunction(virtualDOM) && !(type.prototype && type.prototype.render)
}

function buildFunctionComponent(virtualDOM) {
  return virtualDOM.type(virtualDOM.props || {})// props就在vdom的props里存放
}

function buildClassComponent(virtualDOM) {
  const component = new virtualDOM.type(virtualDOM.props || {})
  const nextVirtualDOM = component.render()
  return nextVirtualDOM
}

// extends React.Component
class Component {
  constructor(props) {
    this.props = props
  }
}
```

55.02





# ^_^

框架的架构

```js
// index.js
import createElement from './xxx'
import render from './xxx'

export default {
  createElement,
  render
}
```

​	这样框架的使用者就可以方便的使用框架的方法了