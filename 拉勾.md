[toc]

# JavaScript异步编程

## Generator

```js
function *foo() {
  yield 'foo' // 随时使用这个关键字向外返回一个值，但不像return立即结束，而是暂停函数的执行
}
const g = foo() // 调用它不会立即执行，而是得到一个生成器对象
const res = g.next() // 这时候才开始执行, 并拿到返回值
const a = g.next('bar') // 参数会代替yield的返回值
```



# TypeScript

```js
yarn add typescript --dev

在node_modules/.bin目录下有个tsc，可以帮我们编译typescript代码
```



# React

## virtual dom 及 diff

### createElement

```js
function createElement(type, props, ...children) {
  const childElements = [].concat(...children).reduce((result, child) => {
    if(child !== false && child !== true && child !== null) {
      if(child instanceof Object) {
        result.push(child)
      } else {
        result.push(createElement('text', { textContent: child }))
      }
    }
    return result
  }, [])
  return {
    type,
    props: Object.assign({ children: childElements }, props),
    children: childElements
  }
}

返回虚拟dom
处理children, 移除null和布尔值, 处理文本节点
将children挂到props上
```

​	这样jsx就会自动被执行createElement方法，我们就会拿到createElement的返回结果，就是一个virtual dom对象



### render

​	把vdom转换为真实dom ，`ReactDOM.render(virtualDOM, container)`

```js
function render(virtualDOM, container, oldDOM = container.firstChild) {
  diff(virtualDOM, container, oldDOM)
}

function diff(virtualDOM, container, oldDOM) {
  const oldVirtualDOM = oldDOM && oldDOM._virtualDOM
  const oldComponent = oldVirtualDOM && oldVirtualDOM.component
  if(!oldDOM) {
    mountElement(virtualDOM, container)
  } else if(virtualDOM.type !== oldVirtualDOM.type && typeof virtualDOM.type !== 'function') {
    const newElement = createDOMElement(virtualDOM)
    oldDOM.parentNode.replaceChild(newElement, oldDOM)
  } else if(typeof virtualDOM.type === "function") {
    // 组件
    diffComponent(virtualDOM, oldComponent, oldDOM, container)
  } else if(oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
    if(virtualDOM.type === "text") {
      updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)
    } else {
      // 更新元素节点属性
      updateNodeElement(oldDOM, virtualDOM, oldVirtualDOM)
    }

    // 处理key
    // 1. 将拥有key属性的子元素放到单独的一个对象中
    let keyedElements = {}
    for(let i = 0, len = oldDOM.childNodes.lendgh; i<len; i++) {
      let domElement = oldDOM.childNodes[i]
      if(domElement.nodeType === 1) {
        // 元素节点
        let key = domElement.getAttribute('key')
        if(key) {
          keyedElements[key] = domElement
        }
      }
    }

    let hasNoKey = Object.keys(keyedElements).length === 0

    if(hasNoKey) {
      virtualDOM.children.forEach((child, i) => {
        diff(child, oldDOM, oldDOM.childNodes[i])
      })
    } else {
      // 循环virtual DOM的子元素 获取子元素的key属性
      virtualDOM.children.forEach((child, i) => {
        let key = child.props.key
        if(key) {
          let domElement = keyedElements[key]
          if(domElement) {
            // 看看当前位置的元素是不是我们期望的元素
            if(oldDOM.childNodes[i] && oldDOM.childNodes[i] !== domElement) {
              oldDOM.insertBefore(domElement, oldDOM.childNodes[i])
            }
          }
        } else {
          // 新增元素
          mountElement(child, oldDOM, oldDOM.childNodes[i])
        }
      })
    }
    // 删除节点
    let oldChildNodes = oldDOM.childNodes
    if(oldChildNodes.length > virtualDOM.children.lendgh) {
      if(hasNoKey) {
        for(let i=oldChildNodes.length-1; i>virtualDOM.children.length-1; i--) {
          unMountNode(oldChildNodes[i])
        }
      } else {
        // 通过key属性删除节点
        for(let i=0; i<oldChildNodes.length; i++) {
          let oldChild = oldChildNodes[i]
          let oldChildKey = oldChild._virtualDOM.props.key
          let found = false
          for(let n=0; n<virtualDOM.children.length; n++) {
            if(oldChildKey === virtualDOM.children[n].props.key) {
              found = true
              break
            }
          }
          if(!found) {
            unMountNode(oldChild)
          }
        }
      }
    }
  }
}
/**
 * 如果oldDOM不存在，直接将虚拟dom转为真实dom挂载
 *  如果存在就要开始比对了
 *    首先如果是节点类型一样的情况下
 *      如果是文本就更新文本节点，元素就更新元素节点
 */

function unMountNode(node) {
  // 处理方法在96.07，需要判断卸载节点的5种情况
  const virtualDOM = node._virtualDOM
  if(virtualDOM.type === 'text') {
    node.remove()
    return
  }

  let component = virtualDOM.component
  // 如果component存在，就说明节点是由组件生成的
  if(component) {
    component.componentWillUnMount()
  }

  if(virtualDOM.props && virtualDOM.props.ref) {
    virtualDOM.props.ref(null)
  }

  Object.keys(virtualDOM.props).forEach(propName => {
    if(propName.slice(0, 2) === "on") {
      const eventName = propName.toLowerCase().slice(2)
      const eventhandler = virtualDOM.props[propName]
      node.removeEventListener(eventName, eventhandler)
    }
  })

  if(node.childNodes.length > 0) {
    for(let i=0; i<node.childNodes.length; i++) {
      unMountNode(node.childNodes[i])
      i--
    }
  }

  node.remove()
}

function diffComponent(virtualDOM, oldComponent, oldDOM, container) {
  if(isSameComponent(virtualDOM, oldComponent)) {
    // 同一个组件，做组件更新操作
    updateComponent(virtualDOM, oldComponent, oldDOM, container)
  } else {
    // 不是同一个组件
    mountElement(virtualDOM, container, oldDOM)
  }
}

function isSameComponent(virtualDOM, oldComponent) {
  return oldComponent && virtualDOM.type === oldComponent.constructor
}

function updateComponent(virtualDOM, oldComponent, oldDOM, container) {
  // 生命周期53.25
  oldComponent.componentWillReceiveProps(virtualDOM.props)
  if(oldComponent.shouldComponentDidUpdate(virtualDOM.props)) {
    oldComponent.componentWillUpdate(virtualDOM.props)
    // 组件更新
    oldComponent.updateProps(virtualDOM.props)
    let nextVirtualDOM = oldComponent.render()
    nextVirtualDOM.component = oldComponent
    diff(nextVirtualDOM, container, oldDOM)
    oldComponent.componentDidUpdate()
  }
}

function updateTextNode(virtualDOM, oldVirtualDOM, oldDOM) {
  if(virtualDOM.props.textContent !== oldVirtualDOM.props.textContent) {
    oldDOM.textContent = virtualDOM.props.textContent
    oldDOM._virtualDOM = virtualDOM
  }
}
/**
 * 如果textContent不一致，直接更新oldDOM的textContent
 * 记得把新的虚拟dom继续放到dom元素上以备下次diff
 */

function isFunction(virtualDOM) {
  return virtualDOM && typeof virtualDOM.type === "function"
}
/**
 * 判断是否是一个组件
 * 如果virtualDOM的type是函数类型说明是
 */

function mountElement(virtualDOM, container, oldDOM) {
  if(isFunction(virtualDOM)) {
    // Component
    mountComponent(virtualDOM, container, oldDOM)
  } else {
    // 普通jsx
    mountNativeElement(virtualDOM, container, oldDOM)
  }
}
/**
 * 如果是组件调用组件方法
 * 如果是普通元素调用普通元素方法
 */

function mountNativeElement(virtualDOM, container, oldDOM) {
  let newElement = createDOMElement(virtualDOM)
  if(oldDOM) {
    container.insertBefore(newElement, oldDOM)
  } else {
    container.appendChild(newElement)
  }
  if(oldDOM) {
    unMountNode(oldDOM)
  }
  
  let component = virtualDOM.component
  if(component) {
    component.setDOM(newElement)
  }
}
/**
 * 挂载普通jsx元素
 *  调用createDOMElement返回真实dom并插入container
 */

function createDOMElement(virtualDOM) {
  let newElement = null
  if(virtualDOM.type === "text") {
    newElement = document.createTextNode(virtualDOM.props.textContent)
  } else {
    newElement = document.createElement(virtualDOM.type)
    updateNodeElement(newElement, virtualDOM)
  }
  // 存放旧的vdom
  newElement._virtualDOM = virtualDOM
  virtualDOM.children.forEach(child => {
    mountElement(child, newElement)
  })
  if(virtualDOM.props && virtualDOM.props.ref) {
    virtualDOM.props.ref(newElement)
  }

  return newElement
}
/**
 * 通过判断是否是text调用dom的创建方法
 *  如果不是text记得更新属性
 *  还要记得把旧的virtualDOM挂到元素上
 *  递归挂载子元素
 */

function updateNodeElement(newElement, virtualDOM, oldVirtualDOM = {}) {
  const newProps = virtualDOM.props || {}
  const oldProps = oldVirtualDOM.props || {}
  // 更新属性
  Object.keys(newProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if(newPropsValue !== oldPropsValue) {
      if(propName.slice(0,2) === 'on') {
        const eventName = propName.toLowerCase().slice(2)
        newElement.addEventListener(eventName, newPropsValue)
        if(oldPropsValue) {
          newElement.removeEventListener(eventName, oldPropsValue)
        }
      } else if(propName === "value" || propName === "checked") {
        // value || checked 不能用setAttribute设置
        newElement[propName] = newPropsValue
      } else if(propName !== 'children') {
        if(propName === "className") {
          newElement.setAttributes('class', newPropsValue)
        } else {
          newElement.setAttributes(propName, newPropsValue)
        }
      }
    }
  })
  // 判断属性被删除的情况，old里面有，new里面没有
  Object.keys(oldProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if(!newPropsValue) {
      // 属性被删除了
      if(propName.slice(0, 2) === 'on') {
        const eventName = propName.toLowerCase().slice(2)
        newElement.removeEventListener(eventName, oldPropsValue)
      } else if(propName !== "children") {
        newElement.removeAttribute(propName)
      }
    }
  })
}
/**
 * 更新属性就是从props里拿，遍历它,如果新属性与旧属性不相等
 *  就给加上新的属性，同时需要判断如下几种情况
 *  事件，value||checked，children，className，普通属性
 * 删除旧的属性，遍历旧的props，如果和新的不一致就删除它
 */

function mountComponent(virtualDOM, container, oldDOM) {
  let component = null
  const nextVirtualDOM = null
  if(isFunctionComponent(virtualDOM)) {
    // 函数组件
    nextVirtualDOM = buildFunctionComponent(virtualDOM)
  } else {
    // 类组件，原型上面有render方法
    nextVirtualDOM = buildClassComponent(virtualDOM)
    component = nextVirtualDOM.component
  }
  if(isFunction(nextVirtualDOM)) {
    mountComponent(nextVirtualDOM, container, oldDOM)
  } else {
    mountNativeElement(nextVirtualDOM, container, oldDOM)
  }
  // 处理组件ref
  if(component) {
    component.componentDidMount()
    if(component.props && component.props.ref) {
      component.props.ref(component)
    }
  }
}
/**
 * 需要判断是函数组件还是类组件
 *  执行对应的方法拿到虚拟dom
 *  再根据虚拟DOM执行对应的挂载方法
 */

function isFunctionComponent(virtualDOM) {
  const type = virtualDOM.type
  return type && isFunction(virtualDOM) && !(type.prototype && type.prototype.render)
}
/**
 * 看原型上是否有render方法
 */

function buildFunctionComponent(virtualDOM) {
  return virtualDOM.type(virtualDOM.props || {})// props就在vdom的props里存放
}
/**
 * 函数组件直接执行构造函数并传入props拿到vdom
 */

function buildClassComponent(virtualDOM) {
  const component = new virtualDOM.type(virtualDOM.props || {})
  const nextVirtualDOM = component.render()
  nextVirtualDOM.component = component
  return nextVirtualDOM
}
/**
 * 类组件实例化其构造函数（传入props），并执行它的render方法拿到vdom
 */

// extends React.Component
class Component {
  constructor(props) {
    this.props = props
  }
  setState(state) {
    this.state = Object.assign({}, this.state, state)
    // 获取最新的要渲染的vdom对象
    let virtualDOM = this.render()
    let oldDOM = this.getDOM()
    let container = oldDOM.parentNode
    diff(virtualDOM, container, oldDOM)
  }
  setDOM(dom) {
    this._dom = dom
  }
  getDOM() {
    return this._dom
  }
  updateProps(props) {
    this.props = props
  }
  // 生命周期函数
  // ...
  componentDidMount() {}
}
/**
 * 把props挂到类上
 */
```



### diff 过程

​	在比对的时候是执行同级比对，父元素和父元素进行比对，子元素和子元素进行比对，它是不会发生跨级比对的。

- 如果比对时两个节点类型相同

  就看看这个节点是什么类型，如果是文本类型，就比较文本内容是否相同，如不相同就用新的文本节点替换旧的文本节点，如果是元素节点，就比较元素节点的属性，看看新节点的属性值是否和旧节点的属性值相同，如果相同不做处理，如果不同就用新节点属性值替换旧节点属性值，再看看新节点中是否有被删除的属性，使用旧节点属性名称去新节点属性中取值，取不到说明该属性被删除了

  节点比对时执行的是深度优先，递归的对比子元素

- 如果比对时两个节点类型不同

  就没有必要进行比对了，只需要使用新的vdom对象去生成新的dom对象，然后使用新的dom对象去替换旧的dom对象就可以了

- 删除节点

  删除节点发生在节点更新以后并且发生在同一个父节点下的所有子节点上，节点更新完成以后如果旧节点对象的数量多于新节点的数量，就说明有节点需要被删除

​		

### 获取ref

```jsx
render() {
  return (
  	<input ref={input => (this.input = input)} />
    <Cmp ref={cmp => (this.cmp = cmp)}/>
    <button onClick={() => { console.log(this.input.value) }}></button>
  )
}
```

实现思路

​	在创建节点时判断vdom是否有ref属性，如果有就调用ref属性中所存储的方法并且将创建出来的DOM对象作为参数传递给ref方法，这样在渲染组件节点时就可以拿到元素对象并将元素对象存储为组件属性了

```js
if(virtualDOM.props && virtualDOM.props.ref) {
  virtualDOM.props.ref(newElement)
}
```



### key 属性

#### 节点对比

​	实现思路是在两个元素进行比对时，如果类型相同，就循环旧的DOM元素的子元素，查看其身上是否有key属性，如果有就将这个子元素的DOM对象存储在一个JS对象中，接着循环要渲染的vdom的子元素，在循环过程中获取到这个子元素的key属性，然后使用这个key属性到JS对象中查找DOM对象，如果能找到说明这个元素是已经存在的，是不需要重新渲染的。如果通过key属性找不到这个元素，就说明这个元素是新增的是需要渲染的

#### 节点卸载

​	在比对节点的时候，如果旧节点的数量多于要渲染的新节点的数量就说明有节点要被删除了，继续判断keyedElements对象中是否有元素，如果没有就用索引的方式删除，如果有就要使用key比对的方式删除。

​	实现思路是循环旧节点，在循环旧节点的过程中获取旧节点对应的key属性，然后根据key属性在新节点中查找这个旧节点，如果找到就说明这个旧节点没有被删除，如果没有找到，就说明节点被删除了，调用卸载节点的方法卸载节点即可

​	卸载节点并不是直接删除就可以了，还需要考虑一些情况

1. 如果是文本节点可以直接删除
2. 如果是组件，则还需调用其生命周期函数
3. 如果包含了其他组件生成的节点，需要调用其他组件的卸载生命周期函数
4. 如果有ref，删除通过ref属性传递给组件的DOM节点对象
5. 如果有事件，需要删除事件对应的事件处理函数

# ^_^

框架的架构

```js
// index.js
import createElement from './xxx'
import render from './xxx'

export default {
  createElement,
  render
}
```

​	这样框架的使用者就可以方便的使用框架的方法了