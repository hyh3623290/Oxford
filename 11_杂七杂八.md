2019年3月

# ES5核心知识点

1⃣️

```js
alert(a)
a()
var a = 3
function a() {
  alert(10)
}
alert(a)
a = 6
a()
```

- 变量提升
- 函数提升
- 函数提升优先于变量提升，也就是函数在最上头
- 如果变量名和函数名重名，变量又没有被赋值，则函数生效

```js
function
10
3
报错: a is not function
```





2⃣️ 

```js
var a = function yideng(num) {
  yideng = num
  console.log(typeof yideng)
  return 1
}
a(1)
console.log(typeof yideng())
```

- yideng是只读的，且只在内部使用。在node中这样使用其实一般就是为了调错的

```js
function
yideng is not defined  
```



3⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: function() {
    console.log(this.a)
  }
}
test.init() // 40
var fn = test.init()
fn() // 20
```

- this谁调用指谁，init是谁执行的？-> test	fn是谁执行的 -> window



4⃣️ 🍇

```js
this.a = 20
var test = {
  a: 40,
  init: function() {
    function go() {
      console.log(this.a)
    }
    go()
  }
}
test.init() // 20
```

- `test.init()` 是 `go()` `go`没人调用, 所以是`window`
- ⚠️ 总结：只要函数执行前面没有点，你就给它加个window





5⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: function() {
    function go() {
      console.log(this.a)
    }
    return go
  }
}
var s = test.init()
s() // 20
```

- 与上同理





6⃣️

```js
function test(a) {
  this.a = a
}
test.prototype.a = 20
test.prototype.init = function() {
  console.log(this.a)
}
var s = new test(30)
s.init() // 30
```

- 构造函数的值优先于原型链





7⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: function() {
    console.log(this.a)
  }
} // 缺了一个分号，报错
(function(){
  var fn = test.init()
  n()
})()
```





8⃣️

```js
this.a = 20
var test = {
  a: 40,
  init: () => {
    console.log(this.a)
  }
}
test.init() // 20
var fn = test.init()
fn() // 20
```

- 箭头函数绑定父级作用域，跟写bind的意思一模一样
- ⚠️ 总结：使用箭头函数就不要管点了





9⃣️

```js
this.test = 11
var s = {
  a: function() {
    console.log(1)
    console.log(this)
    console.log(this.test)
  },
  b() {
    console.log(this.test)
  }
}

var f = s.a.bind(this)
new f() // 1 a{} undefined 没有new的话第二个输出window
var f2 = s.b.bind(this)
new f2() // 报错
```

- es6简写方式不支持new，包括箭头函数
- new了以后this指向那个实例，所以输出`a{}`

```js
function f() {console.log(this)}

new f() // f{}
```







🔟

```js
this.a = 20
var test = {
  a: 40,
  init: () => { // function()
    console.log(this.a)
    function go() {
      this.a = 60
      console.log(this.a)
    }
    go.prototype.a = 50
    return go
  }
}
console.log(1+'*********************')
test.init()
console.log(2+'*********************')
var p = test.init()
console.log(3+'*********************')
p()
console.log(4+'*********************')
new (test.init())()
```

20 20 60 60 60

```js
 1*********************
// 20
 2*********************
// 20
 3*********************
// 60
 4*********************
// 60
// 60
```





1⃣️1⃣️ new 运算符的优先级到底是什么样的

```js
function Foo() {
    getName = function() {
        console.log(1);
    };
    return this;
}
Foo.getName = function() {
    console.log(2);
};
Foo.prototype.getName = function() {
    console.log(3);
};
var getName = function() {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```



1⃣️2⃣️

```js
function test(m) {
  m = {
    v: 5
  }
}
var m = {
  k: 30
}
test(m)
alert(m.v) // undefined

function test(m) {
  m.v = 20
}
var m = {
  k: 30
}
test(m)
alert(m.v) // 20

//上面为了迷惑
function test(a) {
  a.v = 20
}
var m = {
  k: 30
}
test(m)
alert(m.v) // 20
```

- 函数的参数是按值传递，和外面什么关系都没有
- 但后面例子，a和m的指向是同一个地址





1⃣️3⃣️

```js
function yideng() {
  console.log(1)
}
(function(){
  // var yideng -> 现代浏览器
  if(false) {
    function yideng() {
      console.log(2)
    }
  }
  yideng()
})()
```

- 浏览题问题，三种结果

  1. 老式浏览器 - 函数提升输出2
  2. 现代浏览器会将一灯提上来然后报错
  3. 中间某些火狐浏览器输出1

  此外类似`[,,].length`也有2有3





1⃣️4⃣️

请用一句话算出0-100之间学生的学生等级，如90-100为1等生，80-90为2等生以此类推。不允许使用`if switch`

思维：100 10 98 1	有什么关系

```js
10 - 98/10 = 1
```



1⃣️5⃣️

请用一句话遍历变量`a = "abc"`

```js
var a = "abc"

Array.from(a)
[...new Set(a)]
Array.prototype.slice.call(a) // 很多类库都这么干，使用call更灵活
```



🔟6⃣️

请写出JS的继承 1.45 不想看了

```js
function Car(color) {
  this.color = color
}
Car.prototype.show = function() { console.log(this.color) }

function Benz(color) {
  Car.call(this, color)
}
Benz.prototype = Object.create(Car.prototype)
Benz.prototype.test = function() {}

const benz = new Benz("red")
console.log(benz)
```



🔟7⃣️

```js
var length = 10
function fn(){
  console.log(this.length)
}
var yideng = {
  length: 5,
  method: function(fn) {
    fn()
    arguments[0]()
  }
};
yideng.method(fn, 1)
```

- 没有人调fn，this指向window
- window.length = 页面中iframe的个数



🔟8⃣️

```js
function yideng() {}
yideng.prototype.a = 11
yideng.a // undefined
```

- 你得new它的时候才会去原型链上找



🔟9⃣️

原型链图 + 原型链 第二节





⚠️ 额外：手写bind，深拷贝，防抖节流



⚠️ 看到题目先看提升，其次看点

⚠️ 函数作用域可以做私有变量

# 函数式编程

## why

- 函数式编程是随着 React 的流行受到越来越多的关注 
- Vue 3也开始拥抱函数式编程 
- 函数式编程可以抛弃 this 
- 打包过程中可以更好的利用 tree shaking 过滤无用代码 
- 方便测试、方便并行处理 
- 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda

## what

- 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和 多态来演示事物事件的联系 
- 函数式编程的思维方式：把现实世界的事物和事物之间的联系抽象到程序世界。指的是一种（数据之间）的映射关系

​	  函数式 -> 核心思想是对运算过程进行抽象。代码进行重用，抽象出来的函数都是细粒度的函数，我们可以把它组合成功能更强大的函数

## 一等公民

​	函数是一等公民等意思是可以做为参数，返回值，并且存储在变量中

## 高阶函数

- 函数可以作为参数（forEach，filter）

```js
function forEach(arr, fn) {
  for(let i=0;i<arr.length;i++) {
    fn(arr[i])
  }
}
```



- 函数可以作为返回值（once）

  就是一个函数生成一个函数

```js
function once(fn) {
  let done = false
  return function() {
    if(!done) {
      done = true
      fn.apply(this, arguments)
    }
  }
}
let pay = once(function(money) {
  console.log('pay ${money} RMB')
})

pay(5);pay(5);pay(5);pay(5); // 只执行一次
```

使用高阶函数的意义：

- 高阶函数是用来抽象通用的问题
- 抽象可以帮我们屏蔽细节，只需要关注我们的目标



## 闭包

​	函数和周围的状态（词法环境）的引用捆绑在一起形成闭包

- 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域的成员
- 闭包的本质：函数执行完后会从执行栈中移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员



## 纯函数

​	整个函数式编程的核心

​	固定的输入一定是固定的输出，并且没有任何可观察的副作用，也不依赖任何外部的状态，比如slice和splice就是纯和不纯的

```js
// 例1
var sin = _.memorize(x => {
  console.log(x)
  return Math.sin(x)
})
var a = sin(1)	// 第一次慢
var b = sin(1)	// 现在快了,第二次没有打印x

// 自己实现memorize
function memorize(f) {
  let cache = {}
  return function() {
    let k = JSON.stringify(arguments)
    cache[k] = cache[k] || f.apply(f, arguments) // 第一个参数无所谓
  }
}

// 例2
// 不纯，依赖外部变量
var min = 18
var checkage = age => age > min
// 纯
var checkage = age => age > 18
```

优缺点：

1. 有效降低系统复杂度，此外还有缓存的特性（第一次慢，有了缓存速度极快）。
2. 测试更方便
3. 并行处理，纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数。（ES6以后新增Web Worker可以开启多线程）
4. 将需要依赖的外部变量硬编码在函数内部导致扩展性比较差，柯里化优雅解决。



🍇 **lodash常用方法**

```js
_.first(array)
_.last(array)
_.toUpper('abc')
_.reverse(array)
_.each(array, (item, index) => {
  ...
})
_.includes()
_.findIndex()
_.find()
```





## 柯里化

- 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
- 返回一个新的函数接收剩余的参数，返回结果

```js
var checkage = min => (age => age > min)
var checkage18 = checkage(18)
checkage18(20)
// 有网站只允许18岁观看，18就用的非常多
```

​	这样就可以让我们的纯函数不需要硬编码，并且不需要对外界有太多的依赖

🍇 **lodash的柯里化** `_.curry(fn)`

```js
const _ = require('lodash')

function getSum(a, b, c) {
  return a + b + c
}

const curried = _.curry(getSum)
console.log(curried(1, 2, 3)) // 6
console.log(curried(1)(2, 3)) // 6
console.log(curried(1, 2)(3)) // 6
```



🍇 **案例**

```js
const match = _.curry(function(reg, str) {
  return str.match(reg)
})

const haveSpace = match(/\s+/g) // 包含空格
const haveNumber = match(/\d+/g) // 包含数字

haveSpace('hello world')

const filter = _.curry(function (func, array) {
  return array.filter(func)
})

filter(haveSpace, ['hello', 'wor ld'])

const findSpace = filter(haveSpace)
console.log(findSpace(['hello', 'wor ld']))
```



🍇 **自己实现curry**

```js
function curry(fn) {
  return function curriedFn(...args) {
    if(args.length < fn.length) { 
      return function() {
        return curriedFn(...args.concat(Array.from(arguments)))
      }
    }
    return fn(...args)
  }
}
// fn.length为形参个数
```

​	事实上，柯里化是一种预加载函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新的函数。某种义上讲这是对参数的缓存，是一种较高效的编写函数的方法，让函数变得更灵活，粒度更小。可以把多元函数转换为一元函数。

## 函数组合

​	纯函数和柯里化容易得到洋葱式的代码`f(g(h(x)))`，用函数组合解决，把细粒度的函数组合成一个新的函数

```js
function compose(f, g) {
  return function(value) {
    return f(g(value))
  }
}

const compose = (f, g) => (x => f(g(x)))
var fn = compose(f1, f2) // 默认从右到左进行
fn('k')
```

​	就是接受一些函数作为参数，返回嵌套调用的形式

🍇 **lodash flow & flowRight**

```js
_.flowRight(toUpper, first, reverse) // flowRight从右到左
```



🍇 **自己实现flowRight**

```js
function compose(...args) {
  return function(value) {
    return args.reverse().reduce(function(acc, fn) {
      return fn(acc)
    }, value)
  }
}

const compose = (...args) => value => args.reverse().reduce((acc, fn) => fn(acc), value)
```

🍇 **函数组合要满足结合律**

```js
compose(f, g, h) === componse(compose(f,g), h) === compose(f, compose(g,h))
```

🍇 **调试函数组合**

```js
const log = v => {
  console.log(v)
  return v
}
_.flowRight(a, b, log, d)

const trace = _.curry((tag, v) => {
  console.log(tag, v)
  return v
})
_.flowRight(a, b, trace('d之后，'), d)
```



🍇 lodash / fp模块

​	提供了实用的对函数式编程友好的方法

```js
const fp = require('lodash/fp')
fp.map(fp.toUpper, ['abc'])
fp.map(fp.toUpper)(['abc']) // 自动柯里化
```



## Point Free

​	一种编程风格，具体实现是函数的组合。把数据处理的过程，定义成一种与参数无关的合成运算。不需要用到代表数据的那个参数，只要把一些简单的运算步骤合成在一起即可。使用这种模式需要定义一些辅助的基本运算函数。

- 不需要指明处理的数据 
- 只需要合成运算过程 
- 需要定义一些辅助的基本运算函数

```js
const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))
```









​	本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。

​	不使用所要处理的值，只合成运算过程。中文可以译作"无值"风格。

​	把一些对象自带的方法转换成纯函数，不要命名转瞬即逝的中间变量

```js
const f = str => str.toUpperCase().split('')
// 这个str除了让代码变得更长一点毫无意义
```

​	改写

```js
var toUpperCase = word => word.toUpperCase()
var split = x => (str => str.split(x))

var f = compose(split(' '), toUpperCase)
f("abcd xyz")
```

​	这种方法能帮我们减少不必要的命名，让代码保持简洁和通用。更加灵活



## 声明式与命令式

​	命令式的代码意思就是我们通过编写一条又一条的指令去让计算机执行一些动作，这其中一般会涉及很多繁杂的细节。而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。如for循环对比map。

​	函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全不用考虑函数的内部是怎么实现的，专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。相反，不纯的函数代码会产生副作用或者依赖外部系统环境，使用它们的时候总是需要考虑这些不必要的副作用。在复杂的系统中，对程序员的心智是很大的负担。

## 惰性求值与惰性函数

​	只有当有需要的时候才去求值



## 尾调用优化

​	指函数内部的最后一个动作是函数调用。该函数的返回值直接返回给函数。函数尾调用自身，成为尾递归。递归需要保存大量的调用记录，容易导致栈溢出，如果将递归变成循环，只需保存一个调用记录就不会溢出，成为尾递归优化。

```js
// 先看传统递归
function sum(n) {
  if(n===1) return 1
  return n + sum(n-1)
}

// 尾递归
function sum(x, total) {
  if(x === 1) return x + total
  return sum(x-1, total+x)
}
// 这样调用完后会进入下一个栈，对应的数据信息也跟随进入，无需保留函数调用信息
// 但是浏览器没有实现这个，因为报错了以后只会显示在最后一个函数，不好调试
// !return #function可以强制执行尾递归优化
```







## 范畴与容器







